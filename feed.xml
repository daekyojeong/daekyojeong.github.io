<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://daekyojeong.github.io</id><title>학습 일기장</title><subtitle>A</subtitle> <updated>2021-10-07T22:24:58+09:00</updated> <author> <name>Daekyo Jeong</name> <uri>https://daekyojeong.github.io</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://daekyojeong.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2021 Daekyo Jeong </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[알고리즘] 백준 15961 - 회전 초밥</title><link href="https://daekyojeong.github.io/posts/BOJ98/" rel="alternate" type="text/html" title="[알고리즘] 백준 15961 - 회전 초밥" /><published>2021-10-07T22:00:00+09:00</published> <updated>2021-10-07T22:00:00+09:00</updated> <id>https://daekyojeong.github.io/posts/BOJ98/</id> <content src="https://daekyojeong.github.io/posts/BOJ98/" /> <author> <name>Daekyo Jeong</name> </author> <category term="Algorithm" /> <category term="BOJ" /> <summary> 문제 15961 - 회전 초밥 접근 투 포인터 문제이다. start, end 두 개의 변수를 이용하여 배열을 한 바퀴 돌면 된다. start ~ end 사이에 있는 초밥을 먹는다고 생각하면 된다. start가 0부터 시작해서 n-1까지 돌면 모든 경우의 수를 확인한 것이다. 안겹치는 초밥을 카운팅할 때 바로바로 확인하기 위해서 인덱스를 이용한 헤시맵을 이용했다. 코드 파이썬 코드 import sys input = sys.stdin.readline def twoPointer(arr, n, d, k, c): start = 0 end = 0 hashmap = [0] * 5000 hashmap[arr[start]] += 1 hashma... </summary> </entry> <entry><title>[알고리즘] 백준 1520 - 내리막 길</title><link href="https://daekyojeong.github.io/posts/BOJ97/" rel="alternate" type="text/html" title="[알고리즘] 백준 1520 - 내리막 길" /><published>2021-10-06T22:00:00+09:00</published> <updated>2021-10-06T22:00:00+09:00</updated> <id>https://daekyojeong.github.io/posts/BOJ97/</id> <content src="https://daekyojeong.github.io/posts/BOJ97/" /> <author> <name>Daekyo Jeong</name> </author> <category term="Algorithm" /> <category term="BOJ" /> <summary> 문제 1520 - 내리막 길 접근 DFS와 DP를 이용하여 해결했다. 기본 아이디어는 재귀를 이용한 DFS이다. 여기까진 DFS에 대한 지식만 있다면 쉽게 생각해내고 구현할 수 있다. 0, 0 에서 시작해서 상하좌우 가능한 경로를 재귀적으로 수행하며, 최종 목적지에 도착하면 1을 리턴한다. 하지만 이 경우 board의 크기가 크기 때문에 재귀 스택이 매우 커지며, 시간초과가 날 수 있다. 따라서 visited 배열을 단순히 방문 표시가 아닌 해당 좌표에서 목적지까지 가능한 경우의 수를 입력해주고, 이미 방문한 위치이면 해당 값을 리턴해준다. 코드 파이썬 코드 import sys input = sys.stdin.readline sys.setrecursionlimit(... </summary> </entry> <entry><title>[알고리즘] 백준 16234 - 인구 이동</title><link href="https://daekyojeong.github.io/posts/BOJ96/" rel="alternate" type="text/html" title="[알고리즘] 백준 16234 - 인구 이동" /><published>2021-09-29T22:00:00+09:00</published> <updated>2021-09-29T22:00:00+09:00</updated> <id>https://daekyojeong.github.io/posts/BOJ96/</id> <content src="https://daekyojeong.github.io/posts/BOJ96/" /> <author> <name>Daekyo Jeong</name> </author> <category term="Algorithm" /> <category term="BOJ" /> <summary> 문제 16234 - 인구 이동 접근 어제의 아기 상어와 마찬가지로 BFS와 시뮬레이션이 결합된 문제이다. BFS 기본문제 중에 인접한 영역의 크기를 구하는 문제를 알고 있다면 생각보다 쉽게 접근할 수 있다. 문제에서 주어지는 l, r 조건에 맞는 인접 영역을 구하면 된다. 이 때 영역의 크기뿐 아니라, 영역에 속하는 좌표들도 구해와서 일괄적으로 수정해주면 된다. 프로세스는 다음과 같다. board 전체를 돌며 아직 방문하지 않은 곳에 대해 BFS를 수행한다.(checkVisit) BFS를 수행하며 방문한 좌표를 담아준다.(bfs) 담은 좌표들에 대해 인구수를 조정한다.(changePopulation) 1,2,3의 과정을 변화가 없을 때까지 반복한다. 80%에서 ... </summary> </entry> <entry><title>[알고리즘] 백준 16236 - 아기 상어</title><link href="https://daekyojeong.github.io/posts/BOJ95/" rel="alternate" type="text/html" title="[알고리즘] 백준 16236 - 아기 상어" /><published>2021-09-28T22:00:00+09:00</published> <updated>2021-09-28T22:00:00+09:00</updated> <id>https://daekyojeong.github.io/posts/BOJ95/</id> <content src="https://daekyojeong.github.io/posts/BOJ95/" /> <author> <name>Daekyo Jeong</name> </author> <category term="Algorithm" /> <category term="BOJ" /> <summary> 문제 16236 - 아기 상어 접근 BFS로 접근하면 되는데, 조건이 제법 있는 시뮬레이션 문제이다. 다행히 시간제한은 넉넉해서 전수검사로 BFS를 돌렸다. 프로세스는 다음과 같다. 현재 위치에서 BFS를 수행한다. 잡아먹을 수 있는 물고기 중에 가장 가까운(같다면 문제에서 제시한 조건) 물고기를 찾는다. 잡아먹고 해당 자리로 이동 후 다시 1 수행 이 것을 더 이상 잡아먹을 수 있는 물고기가 없을 때까지 수행한다. findShark 함수는 최초 1회 상어의 위치를 찾기 위해 수행한다. compareMove 함수는 문제에서 제시한 가장 가까운(같으면 가장 위, 같으면 가장 왼쪽)을 비교하는 함수이다. 거리, y, x 순으로 재귀적으로 비교해준다. bfs 함수는 bfs... </summary> </entry> <entry><title>[알고리즘] 백준 9251 - LCS</title><link href="https://daekyojeong.github.io/posts/BOJ94/" rel="alternate" type="text/html" title="[알고리즘] 백준 9251 - LCS" /><published>2021-09-14T22:00:00+09:00</published> <updated>2021-09-14T22:00:00+09:00</updated> <id>https://daekyojeong.github.io/posts/BOJ94/</id> <content src="https://daekyojeong.github.io/posts/BOJ94/" /> <author> <name>Daekyo Jeong</name> </author> <category term="Algorithm" /> <category term="BOJ" /> <summary> 문제 9251 - LCS 접근 DP 문제이다. 문자열의 길이를 하나씩 늘려주면서 DP table을 채워나가면 된다. 문제에 주어진 예시로 확인해보자. S1 = ACAYKP S2 = CAPCAK 일 때, s1 = A s2 = C 이 때 LCS는 0. s1 = A s2 = CA 이 때 LCS는 1. …. s1 = A s2 = CAPCAK 이 때 LCS는 1. s2를 끝까지 돌았으니, s1을 한자리 늘려주고 다시 반복. s1 = AC s2 = C 이 때 LCS는 1. 이런 식으로 끝까지 돌면 된다. table을 직접 채워주면서 따라가보면 규칙이 보인다. 가장 마지막에 추가된 문자들이 서로 같을 때, LCS를 1 늘릴 수 있다. 기준은 마지막 문자들이 추가되기 이전 상태에서... </summary> </entry> </feed>
