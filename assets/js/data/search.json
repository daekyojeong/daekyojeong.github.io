[ { "title": "[알고리즘] 백준 15961 - 회전 초밥", "url": "/posts/BOJ98/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 투포인터, 회전초밥", "date": "2021-10-07 22:00:00 +0900", "snippet": "문제15961 - 회전 초밥접근투 포인터 문제이다.start, end 두 개의 변수를 이용하여 배열을 한 바퀴 돌면 된다.start ~ end 사이에 있는 초밥을 먹는다고 생각하면 된다.start가 0부터 시작해서 n-1까지 돌면 모든 경우의 수를 확인한 것이다.안겹치는 초밥을 카운팅할 때 바로바로 확인하기 위해서 인덱스를 이용한 헤시맵을 이용했다.코드 파이썬 코드import sysinput = sys.stdin.readlinedef twoPointer(arr, n, d, k, c): start = 0 end = ..." }, { "title": "[알고리즘] 백준 1520 - 내리막 길", "url": "/posts/BOJ97/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, DP, DFS, 내리막길", "date": "2021-10-06 22:00:00 +0900", "snippet": "문제1520 - 내리막 길접근DFS와 DP를 이용하여 해결했다.기본 아이디어는 재귀를 이용한 DFS이다.여기까진 DFS에 대한 지식만 있다면 쉽게 생각해내고 구현할 수 있다.0, 0 에서 시작해서 상하좌우 가능한 경로를 재귀적으로 수행하며, 최종 목적지에 도착하면 1을 리턴한다.하지만 이 경우 board의 크기가 크기 때문에 재귀 스택이 매우 커지며, 시간초과가 날 수 있다.따라서 visited 배열을 단순히 방문 표시가 아닌 해당 좌표에서 목적지까지 가능한 경우의 수를 입력해주고, 이미 방문한 위치이면 해당 값을 리턴해준다...." }, { "title": "[알고리즘] 백준 16234 - 인구 이동", "url": "/posts/BOJ96/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, BFS, 시뮬레이션", "date": "2021-09-29 22:00:00 +0900", "snippet": "문제16234 - 인구 이동접근어제의 아기 상어와 마찬가지로 BFS와 시뮬레이션이 결합된 문제이다.BFS 기본문제 중에 인접한 영역의 크기를 구하는 문제를 알고 있다면 생각보다 쉽게 접근할 수 있다.문제에서 주어지는 l, r 조건에 맞는 인접 영역을 구하면 된다.이 때 영역의 크기뿐 아니라, 영역에 속하는 좌표들도 구해와서 일괄적으로 수정해주면 된다.프로세스는 다음과 같다. board 전체를 돌며 아직 방문하지 않은 곳에 대해 BFS를 수행한다.(checkVisit) BFS를 수행하며 방문한 좌표를 담아준다.(bfs) 담..." }, { "title": "[알고리즘] 백준 16236 - 아기 상어", "url": "/posts/BOJ95/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, BFS, 시뮬레이션", "date": "2021-09-28 22:00:00 +0900", "snippet": "문제16236 - 아기 상어접근BFS로 접근하면 되는데, 조건이 제법 있는 시뮬레이션 문제이다.다행히 시간제한은 넉넉해서 전수검사로 BFS를 돌렸다.프로세스는 다음과 같다. 현재 위치에서 BFS를 수행한다. 잡아먹을 수 있는 물고기 중에 가장 가까운(같다면 문제에서 제시한 조건) 물고기를 찾는다. 잡아먹고 해당 자리로 이동 후 다시 1 수행이 것을 더 이상 잡아먹을 수 있는 물고기가 없을 때까지 수행한다.findShark 함수는 최초 1회 상어의 위치를 찾기 위해 수행한다.compareMove 함수는 문제에서 제시한 가장..." }, { "title": "[알고리즘] 백준 9251 - LCS", "url": "/posts/BOJ94/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, LCS, DP", "date": "2021-09-14 22:00:00 +0900", "snippet": "문제9251 - LCS접근DP 문제이다.문자열의 길이를 하나씩 늘려주면서 DP table을 채워나가면 된다.문제에 주어진 예시로 확인해보자.S1 = ACAYKPS2 = CAPCAK일 때,s1 = As2 = C이 때 LCS는 0.s1 = As2 = CA이 때 LCS는 1.….s1 = As2 = CAPCAK이 때 LCS는 1.s2를 끝까지 돌았으니, s1을 한자리 늘려주고 다시 반복.s1 = ACs2 = C이 때 LCS는 1.이런 식으로 끝까지 돌면 된다.table을 직접 채워주면서 따라가보면 규칙이 보인다.가장 마지막에 추가된 ..." }, { "title": "[알고리즘] 백준 2470 - 두 용액", "url": "/posts/BOJ93/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 두 용액, 투포인터, 정렬", "date": "2021-09-13 22:00:00 +0900", "snippet": "문제2470 - 두 용액접근정렬과 투 포인터를 이용하여 풀었다.주어진 배열을 정렬한 후, 시작과 끝점을 잡고 하나씩 옮기며 비교해나갔다.가장 앞을 start, 뒤를 end라고 했을 때, 둘 중에 어떤 것을 옮길지 정해야 했다.start+1과 end-1에 있는 수의 절대값을 비교하여 더 큰 쪽으로 이동해주었다.예를 들어 start+1이 -98, end-1이 99이면, start는 그대로 두고, end를 99로 바꿔주는 식이다.이런식으로 이동해주면 N개의 수가 있을 때 O(N)으로 모든 수를 확인할 수 있다.진행하다보면 start..." }, { "title": "[알고리즘] 백준 1976 - 여행 가자", "url": "/posts/BOJ92/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 여행 가자, BFS", "date": "2021-05-22 14:00:00 +0900", "snippet": "문제1976 - 여행 가자접근BFS를 이용하는 문제이다.조건은 생각보다 쉽다.여행하고자하는 도시 중 하나를 정해서 BFS를 수행하고여행하고자하는 도시들에 모두 방문했는지 체크해주면 된다.문제에서 입력이 인접행렬로 주어져서, 그냥 인접행렬을 사용했다.코드 파이썬 코드from collections import dequedef bfs(adj, start, visit): q = deque() q.append(start) visit[start] = 1 while q: node = q.popleft()..." }, { "title": "[알고리즘] 백준 21761 - 초직사각형", "url": "/posts/BOJ91/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 초직사각형, 그리디, Greedy", "date": "2021-05-21 14:00:00 +0900", "snippet": "문제21761 - 초직사각형접근그리디 알고리즘이다.4개 숫자의 곱을 최대화하는게 목적이다.이 때 주어지는 카드 중에 K개만을 선택해야 한다.결국 주어진 카드 중에 부피를 최대화할 수 있는 카드를 선택해야 한다.이를 위해서 주어지는 카드들을 문자 A,B,C,D에 따라 나누고, 각 그룹별로 정렬해준다.각 문자 그룹에서 가장 큰 값들, 즉 4개의 값만 연산해보고 비교하면 된다.이 과정을 K번 반복하면 된다.코드 파이썬 코드import sysinput = sys.stdin.readlinedef calcSize(arr): ans..." }, { "title": "[알고리즘] 백준 21756 - 지우개", "url": "/posts/BOJ90/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 지우개", "date": "2021-05-21 14:00:00 +0900", "snippet": "문제21756 - 지우개접근하나씩 확인하는 방식을 확인했다.큐를 이용해도 될것 같은데, 그냥 간단하게 배열 두개를 이용해서 옮겨다녔다.기준 배열에서 짝수번째 수들만 새로운 배열에 담아준다.새로운 배열을 기준배열로 삼고 다시 이를 반복한다.수가 한개 남을 때까지.코드 파이썬 코드n = int(input())arr = [i+1 for i in range(n)]tmp = []while len(arr) != 1: for idx, item in enumerate(arr): if idx % 2: t..." }, { "title": "[알고리즘] 백준 1427 - 소트인사이드", "url": "/posts/BOJ89/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 소트인사이드, 정렬", "date": "2021-05-21 14:00:00 +0900", "snippet": "문제1427 - 소트인사이드접근간단한 문제이다.입력 받은 숫자를 한 글자씩 분리한 다음 정렬해주면 된다.코드 파이썬 코드n = list(str(int(input())))n.sort(reverse=True)print(int(&#39;&#39;.join(n)))" }, { "title": "[알고리즘] 백준 10610 - 30", "url": "/posts/BOJ88/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 그리디, Greedy", "date": "2021-05-17 14:00:00 +0900", "snippet": "문제10610 - 30접근그리디 알고리즘이다.우선 30의 배수가 되려면 3의 배수인 동시에 10의 배수가 되어야 한다.따라서, 3의 배수를 만족하기 위해 각 자리 수의 합이 3으로 나누어 떨어지는지 확인하고, 0이 한개라도 존재하는지 확인한다.조건을 모두 만족한 경우에, 작은 수부터 뒷자리에 채워넣으면 된다.코드 파이썬 코드n = list(str(int(input())))arr = [0] * 10zeroCheck = FalsesumCheck = 0for item in n: num = int(item) arr[num..." }, { "title": "Recommendation System", "url": "/posts/AI1/", "categories": "AI, Theory", "tags": "IT, AI, Machine Learning, Deep Learning, Recommendation, 추천", "date": "2021-05-15 23:00:00 +0900", "snippet": "Contents 추천 시스템 기본 용어 Overview Candidate Generation Embedding Space Similarity Measures 추천 시스템기본 용어 Item(documents)추천하고자 하는 항목들을 의미한다.예를 들어, 영상 추천 시스템이라면 Item은 영상이 되고, 음악 추천 시스템이라면 Item은 음악이 된다. Query(context)추천을 위해 사용하는 정보를 의미한다...." }, { "title": "[알고리즘] 백준 17608 - 막대기", "url": "/posts/BOJ87/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 막대기, 스택, stack", "date": "2021-05-14 14:00:00 +0900", "snippet": "문제17608 - 막대기접근스택을 활용하면 간단하다.오른쪽에서 본다고 했으니 배열의 끝에서부터 숫자를 하나씩 꺼낸다.현재까지 꺼낸 값들 중 max값을 계속 업데이트하며,현재 max보다 크다면 정답에 +1을 해준다.코드 파이썬 코드import sysinput = sys.stdin.readlinen = int(input())arr = [int(input()) for _ in range(n)]ans = 0nowMax = 0while arr: item = arr.pop() if item &amp;gt; nowMax: ..." }, { "title": "[알고리즘] 백준 1987 - 알파벳", "url": "/posts/BOJ86/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 알파벳, BFS", "date": "2021-05-12 14:00:00 +0900", "snippet": "문제1987 - 알파벳접근사실 정확한 BFS는 아니다.약간 변형을 했다.이 문제는 여태 거쳐온 곳과 알파벳이 같은 곳에 가지못한다.따라서 여태 거쳐온 곳에 대한 정보가 필요하다.따라서 큐에 현재 좌표와 만들어진 단어를 함께 저장한다.그렇게 했더니 시간초과가 났다.고민을 해봤는데, 따로 visit 배열을 두고 방문체크를 하지 않아서, 중복이 굉장히 많을 것 같았다.이 문제는 이미 방문한 곳이라도 다른 길로해서 다시 방문한 경우 정답일 수도 있기 때문에, visit 체크를 하기가 애매하다.따라서, q에 중복을 담는 것을 최대한 피..." }, { "title": "모델 평가 3", "url": "/posts/AI5/", "categories": "AI, Theory", "tags": "IT, AI, Machine Learning, Deep Learning", "date": "2021-05-11 15:00:00 +0900", "snippet": "Contents 모델 평가 하이퍼파라미터 튜닝 그리드 탐색(Grid Search) 랜덤 탐색(Random Search) 베이지안 최적화(Bayesian Optimization) 과적합(Over-Fitting), 과소적합(Under-Fitting) 과적합 방지 과소적합 방지 모델 평가하이퍼파라미터 튜닝하이퍼파라미터는 모델 성능에 크게 ..." }, { "title": "[알고리즘] 백준 1759 - 암호 만들기", "url": "/posts/BOJ85/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 암호 만들기, Brute Force", "date": "2021-05-11 14:00:00 +0900", "snippet": "문제1759 - 암호 만들기접근사전 순으로 정렬한 후 순서에 맞게 중복없이 l개를 선택한다.이게 정답 후보가 된다.이제 정답 후보 중에 주어진 규칙인 자음, 모음의 개수를 확인하고 맞는 것을 최종적으로 출력한다.코드 파이썬 코드def roleCheck(arr, vowel): minV = 1 minC = 2 ans = [] for item in arr: vCnt = 0 cCnt = 0 for s in item: if s in vowel: ..." }, { "title": "[알고리즘] 백준 2217 - 로프", "url": "/posts/BOJ84/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 로프, 수학", "date": "2021-05-11 14:00:00 +0900", "snippet": "문제2217 - 로프접근모든 로프에 걸리는 중량이 같다는 것이 핵심이다.즉 n개의 로프를 사용했을 때 들 수 있는 최대 무게는 n개의 로프중 최소값 * n이다.코드 파이썬 코드n = int(input())arr = [int(input()) for _ in range(n)]arr.sort(reverse = True)ans = 0for idx, item in enumerate(arr): ans = max(ans, item * (idx+1))print(ans)" }, { "title": "[알고리즘] 백준 1094 - 막대기", "url": "/posts/BOJ83/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 막대기, 수학", "date": "2021-05-11 14:00:00 +0900", "snippet": "문제1094 - 막대기접근문제를 쉽게 보면, 결국 주어지는 n을 2의 제곱수들의 합으로 표현하는 방법 중 가장 적은 항의 개수를 묻는 것이다.예를 들어, 23은 16+4+2+1로 표현할 수 있고, 이 것보다 짧게 표현하는 것은 불가능하다.코드 파이썬 코드n = int(input())nowN = 64ans = 0while n: if nowN &amp;lt;= n: n -= nowN ans+=1 nowN //= 2print(ans)" }, { "title": "[알고리즘] 백준 2455 - 지능형 기차", "url": "/posts/BOJ82/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 지능형 기차, 수학", "date": "2021-05-11 14:00:00 +0900", "snippet": "문제2455 - 지능형 기차접근한 줄씩 입력 받는 동시에 현재 기차에 남은 인원을 연산한다.그리고 최대값을 구한다.코드 파이썬 코드ans = 0nowCnt = 0for _ in range(4): outCnt, inCnt = map(int, input().split()) nowCnt = nowCnt + inCnt - outCnt ans = max(ans, nowCnt)print(ans)" }, { "title": "[알고리즘] 백준 5543 - 상근날드", "url": "/posts/BOJ81/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 상근날드, 수학", "date": "2021-05-11 14:00:00 +0900", "snippet": "문제5543 - 상근날드접근입력받은 배열을 버거와 음료수로 분리하고, 각각 최소값을 구해주면된다.그 후 두 개를 더하고 50을 빼면 정답. 코드 파이썬 코드arr = [int(input()) for _ in range(5)]burger = min(arr[:3])drink = min(arr[3:])sets = burger + drink - 50print(sets)" }, { "title": "[알고리즘] 백준 21735 - 눈덩이 굴리기", "url": "/posts/BOJ80/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 눈덩이 굴리기, 완전 탐색, Brute Force", "date": "2021-05-10 14:00:00 +0900", "snippet": "문제21735 - 눈덩이 굴리기접근m이 작아서 완전 탐색으로 풀었다.0번째 칸에서 시작해서 한 턴에 한칸, 혹은 두 칸을 가는 경우에 대해 m번 째 턴까지 모든 경우를 확인했다.코드 파이썬 코드def bf(arr, idx, m, cnt, nowSize, flag): if idx &amp;gt;= len(arr): return nowSize if m == cnt: return nowSize nowSize = nowSize // flag + arr[idx] ans1 = bf(arr,..." }, { "title": "[알고리즘] 백준 19941 - 햄버거 분배", "url": "/posts/BOJ79/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 햄버거 분배, 그리디, Greedy", "date": "2021-05-10 14:00:00 +0900", "snippet": "문제19941 - 햄버거 분배접근그리디 알고리즘이다.앞에서부터 차례대로 보면서 해결하면 된다.나는 사람을 기준으로 해결했다.우선 입력받은 값에서 햄버거와 사람을 나누어 담아준다.인덱스를 기준으로 담아주면 된다.그 후 앞에서부터 사람을 한명 선택하고, 왼쪽에서부터 햄버거를 확인한다.햄버거를 하나 꺼내서 거리를 비교해보고 k보다 멀면 버리고, 작으면 먹는다.이 때 주의할 점은 햄버거의 위치가 사람보다 뒤에 갈 경우이다.햄버거가 앞에 있다면 현재 사람이 먹지 못하면 그보다 뒤에 있는 사람도 당연히 먹지 못하므로, 버려도 상관없다.하..." }, { "title": "[알고리즘] 백준 18870 - 좌표 압축", "url": "/posts/BOJ78/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 좌표 압축", "date": "2021-05-08 14:00:00 +0900", "snippet": "문제18870 - 좌표 압축접근list, set, dict를 모두 사용했다.우선 입력받은 배열을 set으로 바꿔 중복을 없애준 후, 다시 list로 바꿔서 정렬한다.해당 리스트를 이용해 딕셔너리를 구성하는데, key는 요소의 값, value는 요소의 인덱스로 한다.이러면 특정 i가 배열에서 몇 번째로 작은 수인지 바로 확인할 수 있다.그 후 원본 배열을 돌며 딕셔너리에 담아둔 값을 출력한다.코드 파이썬 코드n = int(input())arr = list(map(int, input().split()))sortArr = sort..." }, { "title": "[알고리즘] 백준 5430 - AC", "url": "/posts/BOJ77/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, AC, Deque", "date": "2021-05-08 14:00:00 +0900", "snippet": "문제5430 - AC접근문제 자체보다 입출력 처리가 더 까다로웠다..문제는 거꾸로 뒤집는다고 진짜로 배열을 뒤집고 있으면 안된다.아마 100% 시간초과가 뜰 것이다.D일 때 앞에서만 뺀다고 했다.거꾸로 뒤집는다는 것은 뒤에서 빼겠다는 말과 동일하다.결국 덱으로 구성해주고 R의 횟수에 따라 앞에서 뺄지 뒤에서 뺄지를 정해주면 된다.다 수행한 후에 R의 횟수를 통해 최종적으로 1번만 뒤집을지 말지 결정한다.코드 파이썬 코드from collections import dequedef conductCommand(arr, command..." }, { "title": "[알고리즘] 백준 10816 - 숫자 카드 2", "url": "/posts/BOJ76/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 숫자 카드2, 해시", "date": "2021-05-08 14:00:00 +0900", "snippet": "문제10816 - 숫자 카드 2접근n과 m이 제법 큰 수이다.그냥 배열을 두고 하나씩 탐색한다면, 총 O(nm)이 걸린다.아마 통과하기 힘들어보인다.이 문제는 해시를 사용해야 한다.파이썬은 훌륭한 딕셔너리가 있으니 사용해주자.key에는 숫자가 들어오고, value에 해당 숫자가 몇 번 나왔는지 카운트해준다.코드 파이썬 코드n = int(input())dic = {}arr = list(map(int, input().split()))for item in arr: if item not in dic: dic[ite..." }, { "title": "[알고리즘] 백준 11399 - ATM", "url": "/posts/BOJ75/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, ATM, 그리디, Greedy", "date": "2021-05-08 14:00:00 +0900", "snippet": "문제11399 - ATM접근그리디 문제이다.i 위치에 있는 사람은 항상 i-1번째 위치까지의 시간의 총합만큼 기다려야 한다.때문에 걸리는 시간이 적을 수록 앞에 서는게 좋다.전체 배열을 정렬해주고, 앞에서부터 차례로 걸리는 시간을 연산해주면 된다.코드 파이썬 코드n = int(input())arr = list(map(int, input().split()))arr.sort()now = 0ans = 0for item in arr: ans += (now+item) now += itemprint(ans)" }, { "title": "[알고리즘] 백준 3085 - 사탕 게임", "url": "/posts/BOJ74/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 사탕 게임, Brute force", "date": "2021-05-07 14:00:00 +0900", "snippet": "문제3085 - 사탕 게임접근생각보다 복잡하다고 느꼈다.특정 인덱스 (i, j)가 주어졌을 때, (i, j)에서 가로, 세로를 각각 검사한다.가장 긴 공통 문자열의 길이를 반환한다.이 것을 반복해줘야 하는데, 생각보다 검사해야될 부분이 많아서 꼼꼼하게 생각해야한다.우선 특정 위치의 두 개를 변경했을 때 전체 판을 다 검사하는건 비효율적이다.바뀐 부분에 대해서만 체크해도 된다.이를 위해서 우선 변경이 없는 상태의 판에 대해서 완전탐색을 수행하여 최대 길이를 찾는다.그 후 다시 한번 완전탐색을 수행하며 인접한 두 개를 바꾸고 최대..." }, { "title": "[알고리즘] 백준 2231 - 분해합", "url": "/posts/BOJ73/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 분해합, Brute force", "date": "2021-05-07 14:00:00 +0900", "snippet": "문제2231 - 분해합접근어떤 수의 생성자 중 최소값을 찾아야 한다.최소값을 찾기 위해 1부터 모두 확인해봐야 할까?가능은 하겠지만 비효율적일 것 같다.예를 들어, 1000000의 생성자를 찾는데 굳이 1부터 확인해야 할까?그럼 생성자를 찾을 때 어디서부터 찾기 시작해야 할까?분해합을 만들기 위해선 결국 생성자 자신과 자신의 자릿수의 합이다.그럼 자릿수의 합 만큼 빼주면 생성자가 나온다는 얘기다.각 자리의 최대값은 9이므로, 전체 자리 * 9를 빼주면 가장 최소의 경우가 나올 것이다.예를 들어, 198의 생성자를 찾을 때, 1..." }, { "title": "[알고리즘] 백준 1699 - 제곱수의 합", "url": "/posts/BOJ72/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 제곱수의 합, DP", "date": "2021-05-07 14:00:00 +0900", "snippet": "문제1699 - 제곱수의 합접근DP 문제이다.동전의 개수 x 구하고자 하는 K만큼의 배열을 할당해준다.DP(i, j) = i번째 동전까지를 사용했을 때, j원을 만드는 동전의 최소 개수이다.DP는 처음에 큰 값(나의 경우는 inf를 이용)으로 초기화해준다.동전의 가장 작은 단위가 1원이 아닐 수도 있다.동전을 정렬한 후 가장 작은 단위에 대해서 먼저 DP를 채워준다.예를 들어 가장 작은 단위의 동전이 2원인 경우, 2,4,6,8…단위로 나가면서 DP를 업데이트한다.그럼 DP(0, j)는 0 inf 1 inf 2 inf 3 in..." }, { "title": "[알고리즘] 프로그래머스 - 동굴 탐험", "url": "/posts/Algorithm133/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 동굴 탐험, BFS, DFS", "date": "2021-05-07 11:00:00 +0900", "snippet": "문제동굴 탐험접근호율성 테스트를 통과하기 힘들었다.처음에 기본 골격은 BFS로 잡고 시작했다.효율성 맞추려고 하다보니 BFS랑 DFS랑 조금 짬뽕된 느낌..인접 리스트로 그래프를 표현해준 후, pre_visit라고 해서 선행해야 하는 노드들을 담아주었다.0번 노드에 선행노드가 필요하다면 시작도 못하므로, 항상 False이다.그리고 0번 노드부터 BFS를 시작한다.기본 토대는 BFS 그대로지만 조금 검사해야할 조건이 있다.큐에서 노드를 꺼낸 후, 해당 노드에 선행 노드가 있는지 체크한다.선행 노드가 방문을 완료했다면 기존 BFS..." }, { "title": "[알고리즘] 백준 11000 - 강의실 배정", "url": "/posts/BOJ71/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 강의실 배정, 우선순위큐, 그리디, Greedy", "date": "2021-05-06 14:00:00 +0900", "snippet": "문제11000 - 강의실 배정접근이전의 회의실 배정 문제와 비슷해보인다.비슷해보이긴 하지만, 회의실 배정의 경우 최대한 많은 회의를 하도록 하는게 목표였다면,이번에는 모든 강의를 진행해야 한다.그 때 필요한 강의실을 최소화하는게 목표이다.즉, 겹친다고 버릴 수 없다.처음에는 쉽게 생각하고 강의실 배정 문제와 비슷하게 해결하려 했다.하지만 시간초과 때문에 더 효율적인 방법을 찾아야 했다.결국 모든 강의를 진행해야 하므로, 시작 시간을 기준으로 정렬했다.현재 강의를 시작해야 하는 시점에 강의실이 꽉 차 있으면, 결국 강의실을 하나..." }, { "title": "[알고리즘] 백준 1931 - 회의실 배정", "url": "/posts/BOJ70/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 회의실 배정, 그리디, Greedy", "date": "2021-05-06 14:00:00 +0900", "snippet": "문제1931 - 회의실 배정접근그리디 알고리즘으로 해결할 수 있다.회의 시간표를 끝나는 시간 기준으로 정렬한다.끝나는 시간이 빠른 순서대로 회의를 잡아주면 항상 최적해이다.특정 회의가 끝났을 때 시간을 기준으로 해당 시간보다 늦게 시작하는 회의들 중에서 가장 빨리 끝나는 회의를 진행한다.이를 반복하면 항상 최대한 많은 회의를 진행할 수 있다.코드 파이썬 코드n = int(input())arr = [tuple(map(int, input().split())) for _ in range(n)]arr = sorted(arr, key..." }, { "title": "[알고리즘] 백준 1449 - 수리공 항승", "url": "/posts/BOJ69/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 수리공 항승, 그리디, Greedy", "date": "2021-05-06 14:00:00 +0900", "snippet": "문제1449 - 수리공 항승접근그리디 알고리즘으로 해결할 수 있다.주어지는 위치를 정렬하고 앞에서 부터 테이프를 붙이면 된다.시작점에 맞춰 테이프를 붙이면 항상 최적의 해를 만족한다. 코드 파이썬 코드n, l = map(int, input().split())arr = list(map(int, input().split()))arr.sort()start = arr[0]ans = 1for item in arr: if item &amp;gt;= start+l: ans+=1 start = itempri..." }, { "title": "[알고리즘] 백준 11047 - 동전 0", "url": "/posts/BOJ68/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 동전 0, 그리디, Greedy", "date": "2021-05-06 14:00:00 +0900", "snippet": "문제11047 - 동전 0접근그리디 알고리즘으로 해결할 수 있다.그리디 알고리즘은 특정 조건으로 선택했을 때 결과가 항상 가장 좋음을 보장할 수 있을 때 사용할 수 있다.이 문제의 경우 동전들이 항상 이전 동전의 배수이며, 첫 동전은 1이다.이는 가능한 가장 가치가 큰 동전을 사용했을 때 항상 최상의 결과를 보장해준다.예를 들어 5000원을 만들 때, 5000원 한장을 쓰는 것이 1000원 5장을 쓰는 것보다 좋다.이는 화폐의 단위가 배수를 만족하기에 가능하다. 코드 파이썬 코드n, k = map(int, input().sp..." }, { "title": "[알고리즘] 프로그래머스 - 무지의 먹방 라이브", "url": "/posts/Algorithm132/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 무지의 먹방 라이브", "date": "2021-05-06 11:00:00 +0900", "snippet": "문제무지의 먹방 라이브접근딱히 필요한 알고리즘은 없다.당연하게도 k가 굉장히 크므로 k를 1씩 줄여가며 검사하면 효율성 테스트를 통과 못할 것이다.k를 빠르게 줄여나갈 방법이 필요하다.우선 k가 주어지는 배열 원소의 합보다 크거나 같으면 k초 후에 먹을 음식이 없다는 의미이므로 -1을 리턴한다.이제 본격적으로 k를 어떻게 빠르게 줄여나갈지 생각해보자.전체 배열의 원소를 한 바퀴돌고 오는데는 배열의 길이인 n번이 필요하다.k가 n보다 크다면 충분히 한바퀴를 돌 수 있다는 의미이다.여기서부터 접근을 하면 될 것 같다.k가 n보다 ..." }, { "title": "[알고리즘] 백준 9465 - 스티커", "url": "/posts/BOJ67/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 스티커, DP", "date": "2021-05-05 14:00:00 +0900", "snippet": "문제9465 - 스티커접근DP 문제이다.i번 째 열에서 할 수 있는 행동은 스티커를 선택하지 않거나, 첫 번째 행의 스티커를 선택하거나, 두 번째 행의 스티커를 선택할 수 있다.이를 모두 확인하기 위하여 DP 배열은 n x 3으로 설정하였다.DP(i, j) = i번째 열에서 j행의 스티커를 선택했을 때 최대 점수이다.j행은 0, 1, 2로 이루어져있으며, 0은 아무거도 선택하지 않은 경우이다.각 경우에 대해 생각해보자.아무거도 선택하지 않은 경우는 i-1번째 열에서 어떤 선택을 하던 상관없다.즉 DP(i-1)에서 최대값을 선택..." }, { "title": "[알고리즘] 백준 11726 - 2xn 타일링 2", "url": "/posts/BOJ66/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 2xn 타일링 2, DP", "date": "2021-05-05 14:00:00 +0900", "snippet": "문제11727 - 2xn 타일링 2접근DP 문제이다.기존 타일링 문제가 조금 변형 되었다.DP[i-2]에서 DP[i]를 만드는 방법이 두 가지가 되었다.기존에는 가로 타일 2개를 붙이는 방법만 존재했지만, 이제 2x2짜리 정사각형 타일을 붙일 수도 있다.즉, DP[i]를 구할 때, DP[i-2]는 두배를 해주면 된다.코드 파이썬 코드n = int(input())dp = [1] * (n+1)for i in range(2, n+1): dp[i] = (dp[i-1] + (dp[i-2]*2)) % 10007print(dp[n])" }, { "title": "[알고리즘] 백준 11726 - 2xn 타일링", "url": "/posts/BOJ65/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 2xn 타일링, DP", "date": "2021-05-05 14:00:00 +0900", "snippet": "문제11726 - 2xn 타일링접근DP 문제이다.바로 앞에서 푼 문제랑 동일하다.이 문제 역시 타일을 뒤에만 이어붙이는 식으로 해결한다.DP[i]는 DP[i-2]에 가로 타일 두개를 붙이거나, DP[i-1]에 세로 타일 한개를 붙이면 된다.코드 파이썬 코드n = int(input())dp = [1] * (n+1)for i in range(2,n+1): dp[i] = (dp[i - 1] + dp[i - 2]) % 10007print(dp[n])" }, { "title": "[알고리즘] 백준 1904 - 01타일", "url": "/posts/BOJ64/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 01타일, DP", "date": "2021-05-05 14:00:00 +0900", "snippet": "문제1904 - 01타일접근DP 문제이다.문제 자체는 몇 개만 나열해보면 규칙이 나온다.피보나치수열이다.어떻게 피보나치 수열을 이루는 것일까?DP[i]는 i자리를 만드는 경우의 수이다.그럼 DP[i]는 DP[i-2]의 경우들에 앞 뒤로 00을 붙이는 경우가 있을 수 있고,DP[i-1]에 앞 뒤로 1을 붙이는 경우가 있다.이를 식으로 표현하면, DP[i] = DP[i-1] * 2 + DP[i-2] * 2가 된다.근데 이렇게하면 만들어진 수들 중에 중복이 생기게 된다.정확히 2배..그래서 나누기 2를 해주면 결국,DP[i] = D..." }, { "title": "[알고리즘] 백준 2193 - 이친수", "url": "/posts/BOJ63/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 이친수, DP", "date": "2021-05-05 14:00:00 +0900", "snippet": "문제2193 - 이친수접근DP 문제이다.첫번째 자리는 항상 1이 와야한다.그리고 이전 자리에 1이 나온 경우는 0밖에 올 수 없다.이전 자리에 0이 나온 경우 0,1 모두 올 수 있다.이를 정리하면,i-1번째 자리에 1이 나온 경우, i 번째 자리에는 0밖에 나올 수 없다.i-1번째 자리에 0이 나온 경우, i 번째 자리에는 0,1 모두 나올 수 있다.0, 1에 대해 처리해주기 위해 DP를 2차원으로 만들어 줄 것이다.DP는 n x 2로 만들어 주고, 첫 번째 자리에는 1밖에 못 오기 때문에,DP(1, 0) = 0DP(1, 1..." }, { "title": "[알고리즘] 백준 1463 - 1로 만들기", "url": "/posts/BOJ62/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 1로 만들기, DP", "date": "2021-05-05 14:00:00 +0900", "snippet": "문제1463 - 1로 만들기접근DP를 이용하는 문제이다.바텀업 방식으로 풀었다.N에서 1로 만드는 방법이지만, 1부터 N까지 타고 올라갔다.dp[1]은 0으로 시작하고, n까지 올라가며dp[i] = dp[i-1] + 1을 해준다.이러면 1을 빼는 연산에 대해서 처리해준 것이다.그리고 i가 3으로 나눠지거나 2로 나눠진다면 추가적으로 연산을 진행한다.예를 들어 3으로 나누어진다면, dp[i] = dp[i//3] + 1이 될 것이다.현재 dp에는 1을 뺴는 연산의 결과가 담겨있다.그렇다면 min(dp[i], dp[i//3] + 1..." }, { "title": "[알고리즘] 백준 7785 - 회사에 있는 사람", "url": "/posts/BOJ61/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 회사에 있는 사람, 자료 구조, Dictionary, 딕셔너리", "date": "2021-05-04 14:00:00 +0900", "snippet": "문제7785 - 회사에 있는 사람접근Key를 이름, value를 출근/퇴근 flag로 구성하여 딕셔너리를 만들면 된다.입력이 끝난 후 딕셔너리를 순회하며 현재 value가 출근인 사람들만 추린 후, 정렬하여 출력한다.코드 파이썬 코드import sysinput = sys.stdin.readlineif __name__ == &quot;__main__&quot;: member = {} ans = [] n = int(input()) for _ in range(n): name, flag = inpu..." }, { "title": "[알고리즘] 백준 4796 - 캠핑", "url": "/posts/BOJ60/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 캠핑, 그리디, Greedy", "date": "2021-05-04 14:00:00 +0900", "snippet": "문제4796 - 캠핑접근그리디 문제이다.연속하는 P일 중에 L일은 캠핑을 할 수 있다.즉, P일 중에 캠핑을 한 날이 L일을 넘지않으면 무조건 캠핑을 하는게 이득이다.이에 따라 전체 휴가인 V일을 P일로 나눈 몫을 a라고 할 때, a*L일은 확정적으로 캠핑을 할 수 있는 날이다.문제에서 주어진 예시인 5, 8, 20으로 보면20일을 8로 나눈 몫은 2이다.8일씩 진행되는 프로세스를 풀타임으로 2번 가질 수 있단 의미이고, 8일 중에 5일은 캠핑이 가능하니, 2*5 = 10,즉, 16일 중에 최대 10일은 캠핑이 가능하다는 의미..." }, { "title": "[알고리즘] 백준 2309 - 일곱 난쟁이", "url": "/posts/BOJ59/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 일곱 난쟁이, 완전 탐색, Brute force", "date": "2021-05-04 14:00:00 +0900", "snippet": "문제2309 - 일곱 난쟁이접근완전 탐색 문제이다.문제의 조건을 만족하는 경우를 직접 구해서 출력해야 한다.보통 이런 문제를 풀 때 정답 배열을 만들고 넣었다 뺏다 하는 식으로 풀었었는데,오늘은 조금 다르게 풀어봤다.7명의 키를 더했을 때 문제의 조건인 키의 합이 100이면 True를 반환하고 아닌 경우 False를 반환하게 했다.True가 반환되면 재귀를 종료하고 현재 난쟁이의 키를 배열에 담고 True를 반환한다.이렇게 연쇄적으로 재귀가 종료되며 최종적으로 True를 달성했을 때 더했었던 난쟁이들을 배열에 모두 담아 반환하..." }, { "title": "[알고리즘] 백준 2805 - 나무 자르기", "url": "/posts/BOJ58/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 나무 자르기, 이분 탐색, Binary Search", "date": "2021-05-04 14:00:00 +0900", "snippet": "문제2805 - 나무 자르기접근문제 자체는 간단하다.나무의 높이를 가지고 이분탐색을 진행하면 된다.높이 보다 큰 값에 대해 어짜피 연산을 진행해야 하므로(높이만큼 잘라야한다) 정렬하는데 걸리는 시간이 더 걸릴 것 같아서 따로 정렬은 진행하지 않았다.문제를 정의하기가 조금 까다로웠다.기존 이분 탐색 문제는 뭔가 딱 비례관계를 가지고 있어서, 탐색하는 값을 기준으로 대소 비교를 하면 되었지만,이 문제는 탐색하려는 높이와 얻을 수 있는 나무의 길이가 반비례 관계를 가진다.이 부분만 주의하면 된다.아직도 같거나 작은 값, 혹은 같거나..." }, { "title": "[알고리즘] 백준 5373 - 큐빙", "url": "/posts/BOJ57/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 큐빙, 구현", "date": "2021-04-28 14:00:00 +0900", "snippet": "문제5373 - 큐빙접근너무 끔찍한 구현문제였다…문제보고 하기싫어서 밍기적밍기적거리다가 겨우 풀었다..한 면을 회전시키면 해당 면은 Rotation 해준다.해당 면과 인접한 네개의 면은 인접한 부분들만 다른 면들과 교체해준다.나머지 한 면은 변화가 없다.예를 들어 윗면을 돌린다고하면, 윗면은 테두리가 전체적으로 회전한다.그리고 인접한 앞,뒤,좌,우면은 윗면과 인접한 위쪽 3개를 변경한다.이건 알겠는데…이걸 어떻게 코드로 구현하지..ㅎ…우선 특정 면을 돌리겠단 명령어가 주어졌을 때, 위에서처럼 인접한 4개의 면을 어떻게 찾지....." }, { "title": "[알고리즘] 백준 17144 - 미세먼지 안녕", "url": "/posts/BOJ56/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 미세먼지 안녕, 구현", "date": "2021-04-28 14:00:00 +0900", "snippet": "문제17144 - 미세먼지 안녕접근단순 구현 문제이다.크게 나누면 미세먼지가 확산되는 부분과 공기청정기가 작동하여 공기가 순환되는 부분으로 나뉜다.미세먼지의 확산 같은 경우 전체 칸에서 미세먼지가 동시에 확산된다고 한다.이 부분은 한칸씩 작업을 하게되면 처리할 수 없다.나는 배열을 두 개만들어서 원래 미세먼지 배열을 확인하며 확산되는 내용은 새로운 배열에 표시해주었다.그리고 새로운 배열을 다시 기존 미세먼지 배열로 사용하는 것이다.두 번째는 공기 순환 부분이다.이 부분은 위쪽과 아래쪽의 순환 경로가 다르다.나 같은 경우는 오른..." }, { "title": "[알고리즘] 백준 15685 - 드래곤 커브", "url": "/posts/BOJ55/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 드래곤 커브, 구현, 좌표 회전", "date": "2021-04-28 14:00:00 +0900", "snippet": "문제15685 - 드래곤 커브접근문제를 부분 문제로 쪼개서 생각하면 쉬워진다.우선 드래곤 커브를 그릴 줄 알아야 한다.현재 주어진 좌표 중 마지막 좌표를 기준으로 회전한다.그럼 한 세대를 거칠 때마다 마지막 좌표는 어떻게 바뀔까?마지막 좌표를 기준으로 회전하니, 회전이 끝나면 마지막좌표는 항상 최초좌표가 회전한 좌표가 될 것이다.예를 들어 0세대 좌표 목록이 다음과 같다고 하자.[c1, c2]그럼 c2를 기준으로 회전하게 된다.c2는 중심점이 되므로 회전해도 똑같다.c1을 회전한 결과는 c3가 되고 좌표목록은 이렇게 업데이트 ..." }, { "title": "[알고리즘] 백준 2618 - 경찰차", "url": "/posts/BOJ54/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 경찰차, DP", "date": "2021-04-27 14:00:00 +0900", "snippet": "문제2618 - 경찰차접근너무 어려웠다..사건이 N개 발생했을 때 이동할 수 있는 경우의 수는 2^N개가 된다.일단 DP인건 확실한데,, 어떻게 구성할지 감도 안잡힌다.결국 종이에 N을 작게해서 경우의 수들을 그려봤다.이 때 좌표를 생각하지말고 그냥 사건의 idx로 생각하면 좀더 쉬워진다.좌표는 나중에 다시 생각하자.. 1번 사건, 2번 사건…. N번 사건 타고 들어가면서 경찰차1,2에게 맡기는 경우의 수들을 그려보자.경찰차 1,2를 편의상 x,y라고 하겠다.xxxxxyxyxxyyyxxyxyyyxyyy사건 3개일 때 경우의 수..." }, { "title": "[알고리즘] 백준 17143 - 낚시왕", "url": "/posts/BOJ53/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 낚시왕, 구현, 시뮬레이션", "date": "2021-04-27 14:00:00 +0900", "snippet": "문제17143 - 낚시왕접근뭐랄까 굉장히.. 성가신 구현 문제였다.일단 상어의 상태를 나타내야하는 변수가 너무 많다..클래스나 연습해볼겸 클래스로 구현했다.주어지는 상어의 상태 외에 상어마다 고유 번호를 부여해줬다.(idx)idx는 나중에 상어끼리 잡아먹을 때 활용할 생각으로 만들었다.또한 survive 라는 속성을 주어 해당 상어가 잡아먹혔는지 확인하도록 했다.(그냥 잡아먹혔으면 리스트에서 빼주면 될텐데.. 멍청했다)대신 survive를 둠으로써 list의 인덱스와 상어의 인덱스가 항상 일치하기 때문에 board에 상어의 인..." }, { "title": "[알고리즘] 백준 1561 - 놀이 공원", "url": "/posts/BOJ52/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 놀이 공원, 이분탐색", "date": "2021-04-27 14:00:00 +0900", "snippet": "문제1561 - 놀이 공원접근이분 탐색 문제이다.시간을 변수로 해서 이분탐색을 진행하면된다.최소는 1이고, 최대는 가장 시간이 긴 놀이기구에 n명이 모두 탔을 때다.이분 탐색을 진행하며 해당 시간이 지났을 때 탑승한 인원이 n보다 크다면 정답 후보가 된다.정답 후보들 중 최소값이 n명을 모두 탑승시킬 수 있는 최소 시간이 된다.문제는 n번째 아이가 탑승할 놀이기구를 찾아야한다.따라서 n명이 모두 탈 수 있는 시간을 t라고 하면 우리는 t-1시간이 필요하다.t-1시간에서 놀이기구를 아직 타지 못한 인원과 현재 놀이기구의 상태(탑..." }, { "title": "[알고리즘] 백준 1275 - 커피숍2", "url": "/posts/BOJ51/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 커피숍2, 세그먼트 트리", "date": "2021-04-26 14:00:00 +0900", "snippet": "문제1275 - 커피숍2접근세그먼트 트리는 구간 합을 구할 때 사용하기 좋은 알고리즘이다. 단순히 풀게 되면 N개의 원소를 가진 배열에서 특정 구간 (x, y)의 합을 구하는데 O(N)의 시간이 걸린다.그리고 이러한 구간합을 M번 구해야한다면 O(NM)의 시간이 걸릴 것이다.N과 M이 충분히 커진다면, 이러한 방식은 오랜 시간이 걸릴 것이고, 이를 효율적으로 풀기 위해 세그먼트 트리를 이용하게 된다.세그먼트 트리는 이진 트리의 형식으로 각 구간의 합을 미리 구해놓고 주어진 문제에 대한 답을 연산하는 형식이다.이 방식을 이용하면..." }, { "title": "[알고리즘] 백준 2110 - 공유기 설치", "url": "/posts/BOJ50/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 공유기 설치, 이분탐색", "date": "2021-04-26 14:00:00 +0900", "snippet": "문제2110 - 공유기 설치접근문제 접근은 n의 개수와 좌표의 범위를 봤을 때 이분탐색을 사용해야 한다.그렇다면 어떤 것으로 이분탐색을 해야할까?얼핏 봤을땐 공유기를 어떤 집에 배치해야 하는지가 중요해보여서 집을 이용해서 이분탐색을 생각할 수도 있다.하지만 문제의 핵심은 공유기 사이의 최대 거리를 구하는 문제이다.공유기 사이의 거리는 값의 범위가 명확하고 구하고자 하는 문제와 동일하다.즉, 공유기 사이의 거리를 최소와 최대를 정하여 이분탐색한다면 이분탐색의 결과가 곧 정답이다.우선 주어진 배열을 정렬하자.그리고 최대와 최소를 ..." }, { "title": "[알고리즘] 프로그래머스 - [3차] 자동완성", "url": "/posts/Algorithm131/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 자동완성, Trie", "date": "2021-04-25 11:00:00 +0900", "snippet": "문제[3차] 자동완성접근Trie 알고리즘을 사용했다.Trie 알고리즘은 문자열 검색에 사용되는 알고리즘이다.문자열을 트리형식으로 저장하여 빠르게 검색할 수 있다.각 문자열을 단어 단위로 트리 형식으로 연결한다.트리의 깊이가 단어의 길이가 되는 형식이다.트리 노드의 기본 구조는 다음과 같다.해당 노드의 key, 즉 알파벳 해당 노드의 데이터, 현재 노드까지 왔을 때 완성되는 단어(만약 없는 단어라면 None)해당 노드의 자식 노드들, 딕셔너리 형식으로 상수시간에 검색하도록 한다.해당 문제는 노드의 데이터(현재 노드까지 왔을 때 ..." }, { "title": "[Design Patterns] Observer Pattern", "url": "/posts/Design2/", "categories": "프로그래밍 언어, Design Patterns", "tags": "Programming, Language, Design Patterns, observer pattern", "date": "2021-04-23 23:00:00 +0900", "snippet": "Contents 옵저버 패턴(Observer Pattern) 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용하자. 옵저버 패턴(Observer Pattern)옵저버 패턴은 어떤 사건이 발생 했을 때 객체들에게 사건을 알려줄 수 있는 패턴이다.옵저버 패턴은 크게 주제(subject) 객체와 옵저버 객체로 나누어져있다.주제 객체는 일부 데이터를 관리하며, 데이터가 달라지면 옵저버에게 이를 알린다.옵저버 객체는 주제 객체에 등록되어 있으며 주제의 데이터가 변경되면 변경된 내용..." }, { "title": "모델 평가 2", "url": "/posts/AI4/", "categories": "AI, Theory", "tags": "IT, AI, Machine Learning, Deep Learning", "date": "2021-04-23 15:00:00 +0900", "snippet": "Contents 모델 평가 코사인 거리의 응용 A/B 테스트 모델 평가 방법 홀드아웃(Holdout) 교차 검증 부트스트래핑(bootstrapping) 모델 평가코사인 거리의 응용모델 훈련 과정에서 샘플 사이의 거리를 비교하게 되는 경우들이 많다.이 때 샘플 사이의 거리를 어떻게 측정할 것인지 정하는 것은 최적화와 모델 훈련의 기초가 된다.머신러닝 문제에서 특징은 벡터의 형태로 표현되는 경우가 많..." }, { "title": "[알고리즘] 백준 18258 - 큐 2", "url": "/posts/BOJ49/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 큐", "date": "2021-04-23 14:00:00 +0900", "snippet": "문제18258 - 큐 2접근큐를 사용하는 문제이다.파이썬에서 split(‘ ‘) 와 split()의 차이를 명확히 깨닳은 문제이다.예를 들어, ‘ a b ‘ 가 있을 때split(‘ ‘)를 해주면 [’’, ‘a’, ‘b’, ‘’] 이렇게 나온다.’ ‘ 공백을 기준으로 나누다 보니, a 앞과 b 뒤에 공백도 분리의 기준으로 들어가는 듯 하다.그래서 a 앞 공백 앞에 있는 빈문자 ‘‘를 결과로 담아 주는 듯..반면 split()을 해주면 [‘a’, ‘b’]로 나온다.코드 파이썬 코드from collections import de..." }, { "title": "[알고리즘] 백준 1764 - 듣보잡", "url": "/posts/BOJ48/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 듣보잡, 집합, 교집합", "date": "2021-04-23 14:00:00 +0900", "snippet": "문제1764 - 듣보잡접근교집합을 구하는 문제이다.코드 파이썬 코드import sysinput = sys.stdin.readlinen, m = map(int, input().split(&#39; &#39;))arr1 = set(input().strip() for _ in range(n))arr2 = set(input().strip() for _ in range(m))ans = list(arr1 &amp;amp; arr2)ans.sort()print(len(ans))for item in ans: print(item)" }, { "title": "[알고리즘] 백준 1717 - 집합의 표현", "url": "/posts/BOJ47/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 집합의 표현, union find, 유니온 파인드", "date": "2021-04-23 14:00:00 +0900", "snippet": "문제1717 - 집합의 표현접근유니온-파인드의 아마 가장 기본 연습 문제가 아닐까 생각된다.이미 이전에 한번 풀었기 때문에 크게 문제는 없었다.풀이 자체가 이전 문제와 비슷하기 때문에 사이클 게임을 참고.코드 파이썬 코드import sysinput = sys.stdin.readlinen, m = map(int, input().split(&#39; &#39;))parent = [-1 for i in range(n+1)]def union(x, y): x = find_parent(x) y = find_parent(y) ..." }, { "title": "[알고리즘] 백준 11003 - 최솟값 찾기", "url": "/posts/BOJ46/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 최솟값 찾기, 덱", "date": "2021-04-23 14:00:00 +0900", "snippet": "문제11003 - 최솟값 찾기접근슬라이딩 윈도우를 하며 탐색해야 한다.처음에는 힙(우선순위큐)을 이용하여 문제를 풀었다.힙에 배열의 값과 인덱스를 저장하고, 배열의 값을 이용해서 힙을 구성한다.원소를 순서대로 보면서 힙에 넣고, 힙에 최소값이 슬라이딩 구간을 벗어나면 힙에서 제거하는 식으로 풀었다.힙에서 원소를 추가하거나 제거할 때 힙을 재구성하는 데 로그 n의 시간이 걸린다.이 때문에 시간초과가 난거같다.. 힙보다 빠르게 연산을 수행해야 한다.한참 생각해보니 굳이 최소값을 계속 갱신해주며 힙을 유지할 필요가 있나 싶었다.결국..." }, { "title": "[알고리즘] 백준 1181 - 단어 정렬", "url": "/posts/BOJ45/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 단어 정렬, 정렬", "date": "2021-04-22 14:00:00 +0900", "snippet": "문제1181 - 단어 정렬접근파이썬의 람다는 사랑입니다.새로운 것을 배웠다. sys.stdin.readline 은 개행문자를 포함해서 입력을 받게 된다.나는 주피터 노트북을 쓰기 때문에 test에서는 그냥 input()으로 사용하고 제출할 때만 sys를 사용하다보니 전혀 몰랐다..계속 출력 형식이 틀렸다고 나와서 찾아보니 알게 되었다.문자열을 입력받을 때는 뒤에 .strip()을 붙여줘야 한다.코드 파이썬 코드import sysinput = sys.stdin.readlinen = int(input())arr = list(se..." }, { "title": "[알고리즘] 백준 11650 - 좌표 정렬하기", "url": "/posts/BOJ44/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 좌표 정렬하기, 정렬", "date": "2021-04-22 14:00:00 +0900", "snippet": "문제11650 - 좌표 정렬하기접근파이썬의 람다는 사랑입니다.코드 파이썬 코드import sysinput = sys.stdin.readlinen = int(input())arr = [list(map(int, input().split(&#39; &#39;))) for _ in range(n)]arr = sorted(arr, key=lambda x:(x[0], x[1]))for x, y in arr: print(x, y)" }, { "title": "[알고리즘] 백준 1202 - 보석 도둑", "url": "/posts/BOJ43/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 보석 도둑, 우선순위큐, 그리디 알고리즘, 탐욕법", "date": "2021-04-22 14:00:00 +0900", "snippet": "문제1202 - 보석 도둑접근분명 DP 처럼 생겼는데, 아니다.문제 조건 중에 한 가방에는 최대 한 개의 보석만 담을 수 있다고 명시되어 있다.그럼 가방의 개수만큼 for문을 돌면 될 것 같다.for문이 한번 돌때마다 가방을 하나씩 채우면 된다.어떻게 채워야할까?우선 작은 가방부터 차례대로 채워야하는건 확실하다.가방을 우선 정렬해두고 작은 가방부터 하나씩 채워나간다.그렇다면 이제 가방 한 개를 선택했을 때 해당 가방에 어떤 보석을 담는지가 중요하다.어짜피 하나만 담을 수 있으니, 담을 수 있는 무게들 중에 가장 가치가 큰 보석..." }, { "title": "[알고리즘] 백준 12015 - 가장 긴 증가하는 부분 수열 2", "url": "/posts/BOJ42/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 가장 긴 증가하는 부분 수열, 이분 탐색", "date": "2021-04-22 14:00:00 +0900", "snippet": "문제12015 - 가장 긴 증가하는 부분 수열 2접근LIS 알고리즘이다.DP를 이용해서 풀 수 있지만, 이 방법은 O(n^2)이 걸린다.DP[i] = i를 포함했을 때 최장 길이로, i 보다 작은 이전 수들 중에서 LIS가 가장 긴 곳에 +1을 하는 식이다.이 문제는 입력값이 매우 크기 때문에 위의 방법을 이용하면 시간초과가 나온다.이를 해결하기 위해 이분 탐색을 사용하여 LIS를 업데이트하는 방법을 사용했다.최초에 arr[0]만 담겨있는 DP 배열을 하나 생성한다.그리고 arr를 순서대로 보면서 DP[-1] 번째와 비교하여 ..." }, { "title": "[알고리즘] 백준 10942 - 팰린드롬", "url": "/posts/BOJ41/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 팰린드롬, DP", "date": "2021-04-22 14:00:00 +0900", "snippet": "문제10942 - 팰린드롬접근DP 문제이다.start에서 end까지의 팰린드롬 여부는DP(start, end) = 0 or 1 이다.start에서 end까지의 수가 팰린드롬을 이루기 위한 재귀적 조건은 다음과 같다.arr[start] == arr[end] and DP(start+1, end-1)bottom-up 방식으로 할까하다가, top-down 방식을 연습해보려고 top-down으로 풀었다.dp에 값이 저장되어 있으면 dp값을 출력하면 되고,아직 저장이 안되어 있으면, 재귀적으로 값을 구해준다.재귀 호출 때문에 런타임에러가..." }, { "title": "[알고리즘] 백준 17298 - 오큰수", "url": "/posts/BOJ40/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 오큰수, stack, 스택", "date": "2021-04-21 14:00:00 +0900", "snippet": "문제17298 - 오큰수접근처음에 그냥 이중 포문으로 리스트 전체를 보는 식으로 구현했다.당연하게도 시간초과가 나고… 어떻게 시간을 줄일 수 있을지 고민한 문제..처음엔 아리송했는데, 리스트를 순서대로 보면서 자신보다 큰수가 나오면 그 수는 오큰수를 찾고 더이상 볼 필요가 없다.반대로 큰 수가 아직 나오지 않았으면 큰 수가 나올 때까지 잘 기억해두고 있어야한다.이걸 처리할 방법을 찾아야하는데..[10, 7, 3, 8, 15] 가 있다.10, 7, 3까지는 오큰수를 찾지 못했다.8에 왔을 때 3, 7의 오큰수는 8이란걸 알 수 ..." }, { "title": "[알고리즘] 백준 20040 - 사이클게임", "url": "/posts/BOJ39/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 사이클게임, Cycle, 유니온 파인드", "date": "2021-04-21 14:00:00 +0900", "snippet": "문제20040 - 사이클게임접근사이클 여부를 체크하는 문제이다.사이클을 확인하는 알고리즘은 유니온-파인드 알고리즘이 있다.유니온-파인드 알고리즘은 그래프 알고리즘의 하나로써, 상호 배타적 집합이라고도 부른다.유니온-파인드 알고리즘은 최초에 자기 자신을 루트 로드로 가지는 트리 형태로 시작한다.모든 노드들이 하나의 트리를 가지고 있는 셈이다.그 상태에서 두 개의 노드를 연결한다면 두 노드는 하나의 트리로 합쳐지는 방식이다.이렇게 합치는 과정을 연산하기 위한 union 함수와 합치는 과정에서 두 노드의 루트 노드를 찾는 find ..." }, { "title": "[알고리즘] 백준 1806 - 부분합", "url": "/posts/BOJ38/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 부분합, 투포인터", "date": "2021-04-21 14:00:00 +0900", "snippet": "문제1806 - 부분합접근투 포인터 문제이다.start, end를 두고 원하는 값 S 보다 작으면 end에 위치한 원소를 더하고 end를 한칸 움직인다.S보다 커진다면 start에 있는 값을 빼고 start를 한칸 움직인다.이를 배열의 끝까지 반복하며 S를 만족시키는 end-start 중 최소를 찾는다.종료 조건을 만들다가 코드가 조금 난잡해졌다.처음에는 end와 start를 이용해서 종료 조건을 만들려고 했는데, 잘 모르겠다.end가 끝까지 도달했을 때, 종료되어버리면 틀리는 케이스들이 생긴다.end가 끝에 도달했을 때 no..." }, { "title": "[알고리즘] 백준 2638 - 치즈", "url": "/posts/BOJ37/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 치즈, BFS, Simulation", "date": "2021-04-20 14:00:00 +0900", "snippet": "문제2638 - 치즈접근BFS이자, 시뮬레이션 문제이다.상온에 접촉하는 공기와 접촉하지 않는 공기를 나눠서 구분해줘야 하기 때문에, 치즈로 접근하면 문제가 복잡해진다.공기를 구분해주기 위해 BFS를 수행하고, 치즈에 대해서 다시 BFS를 수행해야 하므로 일을 두 번하는 느낌이다.문제 조건 중 테두리는 항상 공기가 입력된다고 했으므로, (0,0)에는 항상 상온인 공기가 존재한다.(0, 0)에서 BFS를 수행하면 상온인 공기들을 모두 만날 수 있다.이를 통해 상온인 공기를 찾으며 상온인 공기와 접촉하는 치즈들을 모두 찾아줄 수 있..." }, { "title": "[알고리즘] 백준 2096 - 내려가기", "url": "/posts/BOJ36/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 내려가기, DP", "date": "2021-04-20 14:00:00 +0900", "snippet": "문제2096 - 내려가기접근DP 문제이다.한 줄씩 내려오며 만난 숫자를 더하여 최대값, 최소값을 만드는 문제이다.이 때 원하는 곳으로 내려갈 수 있는게 아니라, 이전 상태의 영향을 받게된다.이전 위치에서 좌,우로 최대 한칸밖에 움직이지 못한다.즉, 이전에 (i, 0)번 위치에 있었다면 (i+1, 0), (i+1, 1)까지, (i, 1)번 위치에 있었다면 (i+1, 0), (i+1, 1), (i+1, 2) 이런 식이다.가로는 3칸밖에 되지 않으므로 처음에는 n*3의 배열을 최대값, 최소값에 대해 두개 만들어서 진행했다.DP 구성..." }, { "title": "[알고리즘] 백준 11057 - 오르막 수", "url": "/posts/BOJ35/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 오르막수, DP", "date": "2021-04-20 14:00:00 +0900", "snippet": "문제11057 - 오르막 수접근DP 문제이다.오르막수가 되기 위해선 자신 앞자리의 숫자보다 크거나 같아야한다.이를 통해 DP를 구상하면 된다.나는 DP를 자릿수와 각 자리마다 0~9까지로 하여 10개로 구성했다.DP(i, j) = i번째 자리에 j가 들어왔을 때 가능한 경우의 수이다.DP(2, 3) = 2번째 자리가 3일 때 오르막 수인 경우의 수이다.DP(i, j) = DP(i, j-1) + DP(i-1, j) 이다.즉, 현재 자리수에서 j-1인 경우 + 앞 자리에 j가 나온 경우이며,n자리에서 오르막 수인 경우의 수는 su..." }, { "title": "[알고리즘] 백준 1922 - 네트워크 연결", "url": "/posts/BOJ34/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 네트워크 연결, 최소 스패닝 트리, MST", "date": "2021-04-19 14:00:00 +0900", "snippet": "문제1922 - 네트워크 연결접근최소 스패닝 트리 문제이다.그래프에서 최소 비용을 사용하여 트리 구조를 만든다고 생각하면 된다.그래프 표현은 인접 리스트 방식을 사용했고, 프림 알고리즘을 이용하여 해결했다.방문 여부를 나타내는 배열하나와 현재까지 방문한 노드들 중 다음 노드와 연결하기 위한 최소 비용을 찾기 위해 우선순위 큐를 사용했다.n개의 노드를 연결하기 위해서는 최소 n-1개의 간선이 필요하므로, 연결 과정을 n-1번 반복하면 멈추도록 하였다.코드 파이썬 코드import heapqimport sysinput = sys...." }, { "title": "[알고리즘] 백준 1182 - 부분 수열의 합", "url": "/posts/BOJ33/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 부분 수열의 합", "date": "2021-04-19 14:00:00 +0900", "snippet": "문제1182 - 부분 수열의 합접근보통 원하는 수를 만들거나 초과하면 거기서 멈추지만, 이 문제의 경우 음수도 포함되어 있기때문에 끝까지 돌려봐야한다.코드 파이썬 코드def func(idx, nowSum): if n == idx: if s == nowSum: return 1 else: return 0 return func(idx+1, nowSum) + func(idx+1,nowSum+arr[idx])n, s = map(int, input().split..." }, { "title": "[알고리즘] 백준 1158 - 요세푸스 문제", "url": "/posts/BOJ32/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 요세푸스 문제", "date": "2021-04-18 14:00:00 +0900", "snippet": "문제1158 - 요세푸스 문제접근문제 자체는 간단하다.한 사람씩 제거하면서 움직여야하는데 인덱스 관리를 어떻게 해주느냐가 관건이다.코드 파이썬 코드n, k = map(int, input().split())result = []n = [i+1 for i in range(n)]nowLoc = 0while n: nowLoc += k - 1 size = len(n) if nowLoc &amp;gt;= size: nowLoc %= size result.append(str(n.pop(nowLoc)))pr..." }, { "title": "[알고리즘] 백준 4597 - 패리티", "url": "/posts/BOJ31/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 패리티", "date": "2021-04-18 14:00:00 +0900", "snippet": "문제4597 - 패리티접근1의 개수와 마지막 글자가 e, o 여부에 따라 답이 달라진다.현재 1이 짝수개인지, 홀수개인지 그리고 e인지 o인지 조합하여 4가지 경우에 대해 조건을 주면 된다.코드 파이썬 코드while True: bitString = input() if bitString == &#39;#&#39;: break p = bitString[-1] bitString = bitString[:-1] bitCnt = bitString.count(&#39;1&#39;) if p =..." }, { "title": "[알고리즘] 백준 13458 - 시험 감독", "url": "/posts/BOJ30/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 시험 감독", "date": "2021-04-18 14:00:00 +0900", "snippet": "문제13458 - 시험 감독접근시험장당 총 감독관 한명은 고정이다.그리고 남은 학생을 감당할 수 있는만큼 부 감독관을 넣으면 된다.코드 파이썬 코드n = int(input())arr = list(map(int, input().split(&#39; &#39;)))mainS, subS = map(int, input().split(&#39; &#39;))ans = 0for student in arr: student -= mainS if student &amp;gt; 0: ans += student // su..." }, { "title": "[알고리즘] 백준 13301 - 타일 장식물", "url": "/posts/BOJ29/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 타일 장식물, DP", "date": "2021-04-18 14:00:00 +0900", "snippet": "문제13301 - 타일 장식물접근DP 문제이다.타일의 크기는 피보나치 수열과 같다.타일의 크기에 대한 배열을 n 이라고 하자.둘레에 대한 배열은 size 라고 하자.n에 대한 dp는 피보나치와 마찬가지로 n[i] = n[i-1] + n[i-2] 이다.둘레의 경우 size[i] = size[i-1] + 2n[i] 이다.이전 둘레에 현재 크기를 두번 더하면 현재 둘레가 된다.문제의 그림을 보면 이해가 편할 것이다.코드 파이썬 코드n = int(input())dp_n = [1]*(81)dp_size = [1]*(81)dp_size..." }, { "title": "[알고리즘] 백준 15953 - 상금 헌터", "url": "/posts/BOJ28/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 상금 헌터", "date": "2021-04-18 14:00:00 +0900", "snippet": "문제15953 - 상금 헌터접근주어진 조건으로 상금을 알아내면 된다.주의할 것은 등수는 누적해야 한다.코드 파이썬 코드t = int(input())def fastival1(score): if score == 1: return 5000000 elif 1 &amp;lt; score &amp;lt;= 3: return 3000000 elif 3 &amp;lt; score &amp;lt;= 6: return 2000000 elif 6 &amp;lt; score &amp;lt..." }, { "title": "[알고리즘] 백준 1085 - 직사각형에서 탈출", "url": "/posts/BOJ27/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 직사각형에서 탈출", "date": "2021-04-18 14:00:00 +0900", "snippet": "문제1085 - 직사각형에서 탈출접근상하좌우 가장 가까운 곳을 찾으면 된다.코드 파이썬 코드x, y, w, h = map(int, input().split(&#39; &#39;))print(min(x, w-x, y, h-y))" }, { "title": "[알고리즘] 백준 1284 - 집 주소", "url": "/posts/BOJ26/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 집 주소", "date": "2021-04-18 14:00:00 +0900", "snippet": "문제1284 - 집 주소접근1, 0 인 경우만 따로 처리해주면 된다.코드 파이썬 코드while True: num = list(map(int, list(input()))) if len(num) == 1 and num[0] == 0: break ans = 1 + len(num) for item in num: if item == 1: ans += 2 elif item == 0: ans += 4 else: ..." }, { "title": "[알고리즘] 백준 9019 - DSLR", "url": "/posts/BOJ25/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, DSLR, BFS", "date": "2021-04-16 14:00:00 +0900", "snippet": "문제9019 - DSLR접근이 문제도 방문 배열을 현재 숫자로 이용하면 된다.L, R을 문자열로 사용한다면 연산이 쉽다.하지만 시간초과를 해결할 수 가 없어, 결국 int형으로 몫과 나머지를 이용하여 연산을 진행했다.하지만 이렇게 해도 시간초과가 해결이 안되서, pypy3으로 제출했다.코드 파이썬 코드from collections import dequeimport sysinput = sys.stdin.readlinedef bfs(start, target): q = deque() q.append(start) b..." }, { "title": "[알고리즘] 백준 1525 - 퍼즐", "url": "/posts/BOJ24/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 퍼즐, BFS", "date": "2021-04-16 14:00:00 +0900", "snippet": "문제1525 - 퍼즐접근처음에 문제를 보고 막막했다.BFS로만 접근해선 해결할 수 없어 보였다.3 x 3 배열안에서 이동해가며 원하는 조건을 만족시켜야 하는데,기존 알아왔던 BFS와 다르게 이미 방문했는지 어떻게 체크할 수 있을지 고민하게 된 문제이다.현재 위치를 기준으로 방문 여부를 체크할 수는 없다.이렇게 하면 최대 9번만 움직일 수 있다는 얘기가 되고, 같은 위치에 다시 방문하지 못한다.하지만 이 문제는 주어지는 수들이 어떻게 변하는지에 따라 같은 자리에 다시 와야할 일이 생긴다.결국 방문 여부를 위치가 아닌 다른 것으로..." }, { "title": "모델 평가 1", "url": "/posts/AI3/", "categories": "AI, Theory", "tags": "IT, AI, Machine Learning, Deep Learning", "date": "2021-04-15 15:00:00 +0900", "snippet": "Contents 모델 평가 정확도 Precision, Recall RMSE(평균제곱근오차) ROC(Receiver Operating Characteristic Curve) 곡선 AUC(Area Under Curve) 모델 평가모델에 따라 평가 과정에서 서로 다른 지표를 사용하게 된다.이러한 평가 지표 중 대부분은 모델의 일부 성능에 대한 단편적인 부분만 반영하게 된다.만약 적절한 평가 지표를 사용하지 않는다면, 모델의 문제점을 발견하지 못할 수 있고 잘못된 결론을 ..." }, { "title": "[Anaconda] 윈도우 아나콘다 기본 사용법", "url": "/posts/Anaconda1/", "categories": "Tool, Anaconda", "tags": "Tool, Anaconda, Window", "date": "2021-04-14 23:00:00 +0900", "snippet": "Contents 아나콘다 가상환경 생성 가상환경 확인 가상환경 활성화 가상환경 내부 패키지 확인 가상환경 패키지 설치 주피터 노트북 가상환경 연결아나콘다 가상환경 생성conda create -n [가상환경이름] python=[버전]가상환경 확인conda env list가상환경 활성화conda activate [가상환경이름]가상환경 내부 패키지 확인conda list가상환경 패키지 설치내가 설치한 것들은 또 쓸때 찾아보게 적어놓자conda install jupyter notebook주피터 노트북 가상환경 연결pytho..." }, { "title": "[Design Patterns] Strategy Pattern", "url": "/posts/Design1/", "categories": "프로그래밍 언어, Design Patterns", "tags": "Programming, Language, Design Patterns, strategy pattern", "date": "2021-04-14 23:00:00 +0900", "snippet": "Contents 스트래티지 패턴(Strategy Pattern) 코드에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다. 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다. 상속보다는 구성을 활용한다. 스트래티지 패턴(Strategy Pattern)알고리즘군을 정의하고 각각을 캡슐화하여 교환 가능하도록 만들어준다.코드에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.바뀌는 부분을 따로 뽑아서 캡슐화시키자.그러면 나중에 바뀌지 않는 부분에 영향을 미치..." }, { "title": "[프로그래밍 언어] 파이썬 - Pandas", "url": "/posts/languagePython3/", "categories": "프로그래밍 언어, Python", "tags": "Programming, Language, Python", "date": "2021-04-14 19:00:00 +0900", "snippet": "Contents Pandas 자주 사용하는 문법 정리 Read write Pandas 자주 사용하는 문법 정리Readpd.read_csv(filePath, params)자주 사용하는 params sep = ‘,’ header = None (저장된 파일에 header가 따로 없을 때)writepd.to_csv(filePath, params)자주 사용하는 params sep = ‘,’ header = True index = True encoding = ‘utf-8’" }, { "title": "Feature engineering : 비정형 데이터", "url": "/posts/AI2/", "categories": "AI, Theory", "tags": "IT, AI, Machine Learning, Deep Learning", "date": "2021-04-14 15:00:00 +0900", "snippet": "Contents 비정형 데이터 텍스트 데이터 BOW(Bag of words), N-gram 워드 임베딩 및 딥러닝 모델 Word2Vec 이미지 데이터비정형 데이터정형 데이터의 반대되는 경우로, 하나의 수치로 표현하기 힘들고 값의 의미를 쉽게 파악하기 힘든 데이터들을 말한다.텍스트, 이미지, 음성, 영상 등의 데이터들이 여기에 해당한다.텍스트 데이터BOW(Bag of words), N-gram가장 기본적인 텍스트 표현 방법이다.텍스트..." }, { "title": "[알고리즘] 백준 10026 - 적록색약", "url": "/posts/BOJ23/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 적록색약, BFS", "date": "2021-04-14 14:00:00 +0900", "snippet": "문제10026 - 적록색약접근두 가지 방법으로 접근할 수 있을 것 같다.Board를 한 개만 두고 일반인과 색약인 사람에 대해 각각 visit 배열을 두고 진행하는 방법.혹은, visit를 사용하지 않고, 일반인과 색약인 사람에 대해 각각 Board를 두고 Board에 visit을 체크하는 방법.후자가 더 간단해보여서 후자로 구현하였다.여태 풀었던 BFS는 보통 벽같은게 존재했지만, 여기서는 벽은 없고 각 지점의 값이 같은 곳끼리 영역을 이루는 방식이다.인접한 지역의 값이 시작 지역의 값과 같은지만 체크하며 BFS를 수행하면 ..." }, { "title": "[알고리즘] 백준 2583 - 영역 구하기", "url": "/posts/BOJ22/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 영역 구하기, BFS", "date": "2021-04-14 14:00:00 +0900", "snippet": "문제2583 - 영역 구하기접근2차원 BFS 문제이다.조금 색다른 점은 입력이 좌표 형식이란 점과 주어지는 영역들이 벽이 된다는 점이다.좌표로 주어지는 값이 배열의 index와 조금 달라서, 편의를 위해 좌표 변환 작업을 따로 수행해주었다.coordinateTransformation 함수는 주어지는 좌표를 편하게 board의 배열 좌표로 변환하며, 왼쪽위의 좌표와 오른쪽 아래좌표로 바꿔준다.boardDraw 함수는 변형된 좌표를 가지고 board 판에 벽을 그려준다.코드 파이썬 코드from collections import ..." }, { "title": "[알고리즘] 백준 2667 - 단지번호붙이기", "url": "/posts/BOJ21/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 단지번호붙이기, BFS", "date": "2021-04-14 14:00:00 +0900", "snippet": "문제2667 - 단지번호붙이기접근2차원 BFS 문제이다.영역 개수 검출 및 각 영역의 크기를 구하면 된다.BFS를 수행한 횟수가 영역 개수가 되며, 각 BFS 내부에서 최초 방문을 수행한 횟수가 영역의 크기를 나타낸다.코드 파이썬 코드from collections import dequedef bfs(sy, sx): dx = [0,0,1,-1] dy = [1,-1,0,0] q = deque() q.append((sx, sy)) board[sy][sx] = 2 size = 1 while q:..." }, { "title": "[알고리즘] 백준 5014 - 스타트링크", "url": "/posts/BOJ20/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 스타트링크, BFS", "date": "2021-04-14 14:00:00 +0900", "snippet": "문제5014 - 스타트링크접근1차원 BFS 문제이다.위, 아래로만 이동할 수 있는 1차원 선에서 움직인다고 생각하면 된다.역시 BFS는 몇 번만에 해당 지점에 도착했는지 파악이 쉽고, 처음 도착했을 때 횟수가 최소임을 보장받는다.코드 파이썬 코드from collections import dequedef bfs(start, end): dx = [up, -down] q = deque() q.append(start) while q: now = q.popleft() if now == e..." }, { "title": "[알고리즘] 백준 7562 - 나이트의 이동", "url": "/posts/BOJ19/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 나이트의 이동, BFS", "date": "2021-04-14 14:00:00 +0900", "snippet": "문제7562 - 나이트의 이동접근BFS 문제이다.단지 기존에는 2차원 공간에서 상하좌우로 움직였다면, 여기서는 조금 변형해서 8 곳으로 이동할 수 있다는 것만 다르다.코드 파이썬 코드from collections import dequedef bfs(sx, sy, ex, ey): dx = [-2,-2,-1,-1,1,1,2,2] dy = [1,-1,2,-2,2,-2,1,-1] q = deque() q.append((sx,sy)) while q: nowx, nowy = q.popleft() ..." }, { "title": "[알고리즘] 백준 7576 - 토마토", "url": "/posts/BOJ18/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 토마토, BFS", "date": "2021-04-14 14:00:00 +0900", "snippet": "문제7576 - 토마토접근BFS 문제이다.따로 방문배열을 사용할 필요가 없어서 Board 하나로만 이용했다.BFS의 가장 편한 점은 일반적인 경우에 최초 방문한 지점은 항상 최단 거리로 방문했음을 확신할 수 있다.때문에 최초 방문만 신경써서 처리해주면, 이미 방문한 지점에 대해서는 따로 고민할 필요가 없다.코드 파이썬 코드from collections import dequedef bfs(q): dx = [0,0,1,-1] dy = [1,-1,0,0] ans = 1 while q: nowx, ..." }, { "title": "Feature engineering : 정형 데이터", "url": "/posts/AI1/", "categories": "AI, Theory", "tags": "IT, AI, Machine Learning, Deep Learning", "date": "2021-04-13 23:00:00 +0900", "snippet": "Contents Feature Engineering 정형 데이터 정규화(Normalization) 수치형 데이터 Min-Max Scaling Z-score Normalization 범주형 데이터 순서형 인코딩(ordinal encoding) 원핫 인코딩(one-hot encoding) Feature EngineeringFeature Engineer..." }, { "title": "[알고리즘] 백준 2206 - 벽 부수고 이동하기", "url": "/posts/BOJ17/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 벽 부수고 이동하기, BFS", "date": "2021-04-13 21:00:00 +0900", "snippet": "문제2206 - 벽 부수고 이동하기접근조금 까다로웠던 것 같다.BFS로 푸는 건 맞는 것 같은데, 벽을 최대 한개까지는 부술 수 있다.이걸 어떻게 처리해줄지 고민했던 문제이다.생각보다 단순하게 풀 수 있었는데, 기존에는 벽이 아닌 경우에만 queue에 좌표를 추가해주었다.여기서는 queue에 현재 좌표와 벽을 부쉈는지를 저장해두고,벽을 부수지 않았으면 벽인 경우도 한 번은 이동할 수 있도록 처리해주었다.이 때 방문배열을 벽을 부순적이 없는 경우, 벽을 부순 경우 두개로 사용해주어야 한다.코드 파이썬 코드from collect..." }, { "title": "[알고리즘] 백준 3055 - 탈출", "url": "/posts/BOJ16/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 탈출, BFS", "date": "2021-04-13 21:00:00 +0900", "snippet": "문제3055 - 탈출접근앞에서 풀었던 불 문제와 유사하다.다른 점은 종료 조건이다.앞에선 판을 벗어날 수 있으면 종료했지만, 여기서는 종료 지점이 정해져 있다.주의할 점은 종료지점에는 물이 차지않는다!코드 파이썬 코드from collections import dequeimport sysdx = [0,0,-1,1]dy = [1,-1,0,0]def waterBFS(): waterSize = len(waterQ) while waterSize: nowx, nowy = waterQ.popleft() ..." }, { "title": "[알고리즘] 백준 5427 - 불", "url": "/posts/BOJ15/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 불, BFS", "date": "2021-04-13 21:00:00 +0900", "snippet": "문제5427 - 불접근2차원 공간에서 최단 경로를 찾아야 한다.특이한 점은 불이라는 존재이다.상근이가 1초마다 한 칸을 움직일 수 있듯이 불도 1초마다 인접한 칸으로 전파된다.매 초 불길이 전파되고, 이러한 불에 닿지 않고 출구까지 가는 방법을 찾아야 한다.상근이와 불을 동시에 생각하지 않으면 쉬워질 것 같다.우선 불에 대해서 BFS를 수행하며 불이 전파되는 칸마다 몇 초에 전파 되었는지 기록해주자.예를 들어 다음과 같은 공간이라고 하자.F는 불의 초기 위치이다.F 0 0 00 0 0 00 0 0 0이 때 불의 전파를 기록한다..." }, { "title": "[알고리즘] 백준 1743 - 음식물 피하기", "url": "/posts/BOJ14/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 음식물 피하기, BFS", "date": "2021-04-12 23:00:00 +0900", "snippet": "문제1743 - 음식물 피하기접근2차원 공간에서 영역의 개수를 찾는 문제이다.배추가 심어져 있는 1의 칸 중에 방문하지 않은 칸에 대하여 BFS를 수행한다.BFS를 수행한 횟수가 영역의 개수이다.코드 파이썬 코드import sysfrom collections import dequedx = [0,0,-1,1]dy = [1,-1,0,0]def bfs(i, j): q = deque() q.append((i,j)) visit[i][j] = 1 while q: by, bx = q.popleft() ..." }, { "title": "[알고리즘] 백준 1012 - 유기농 배추", "url": "/posts/BOJ13/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 유기농 배추, BFS", "date": "2021-04-12 23:00:00 +0900", "snippet": "문제1012 - 유기농 배추접근2차원 공간에서 영역의 개수를 찾는 문제이다.배추가 심어져 있는 1의 칸 중에 방문하지 않은 칸에 대하여 BFS를 수행한다.BFS를 수행한 횟수가 영역의 개수이다.코드 파이썬 코드import sysfrom collections import dequedx = [0,0,-1,1]dy = [1,-1,0,0]def bfs(i, j): q = deque() q.append((i,j)) visit[i][j] = 1 while q: by, bx = q.popleft() ..." }, { "title": "[알고리즘] 백준 6593 - 상범 빌딩", "url": "/posts/BOJ12/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 상범 빌딩, BFS", "date": "2021-04-12 23:00:00 +0900", "snippet": "문제6593 - 미로 탐색접근2차원 BFS 문제에서 3차원으로 차원만 늘린 경우이다.2차원일 때는 인접한 4칸을 확인했다면, 3차원일 때는 인접한 6칸을 확인하면 된다.이 때 방문배열인 visit를 -1로 초기화하고 시작한다면 종료지점에 도달할 수 있는지 없는지에 대한 검사가 필요없어진다.이 문제의 경우는 출력 형식이 다르기 때문에 어쩔 수 없이 확인해주어야 한다.코드 파이썬 코드from collections import dequedef bfs(start, end): q = deque() q.append(start..." }, { "title": "[알고리즘] 백준 2178 - 미로 탐색", "url": "/posts/BOJ11/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 미로 탐색, BFS", "date": "2021-04-12 23:00:00 +0900", "snippet": "문제2178 - 미로 탐색접근단순한 2차원 BFS 문제이다.2차원에서 상하좌우 한칸씩 이동하며 목적지까지 몇 번만에 도달했는지 확인하면 된다.코드 파이썬 코드from collections import dequedef bfs(): q = deque() q.append((0,0)) visit[0][0] = 1 while q: nowx, nowy = q.popleft() for x, y in zip(dx, dy): nx = nowx+x ny = ..." }, { "title": "[알고리즘] 백준 2644 - 촌수계산", "url": "/posts/BOJ10/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 촌수계산, BFS", "date": "2021-04-12 23:00:00 +0900", "snippet": "문제2644 - 촌수계산접근문제를 읽었을 때 처음 든 생각은 트리구조였다.하지만 트리구조로 이 문제를 해결하고자 하면, 굉장히 문제가 까다로워진다.단순히 a노드에서 BFS를 이용하여 b 노드를 방문하는데 걸린 거리를 구하면 문제는 간단하게 해결된다.코드 파이썬 코드from collections import dequedef bfs(start, end): q = deque() q.append(start) visit[start] = 0 while q: node = q.popleft() ..." }, { "title": "[알고리즘] 백준 11724 - 연결 요소의 개수", "url": "/posts/BOJ9/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 연결 요소의 개수, BFS", "date": "2021-04-10 23:00:00 +0900", "snippet": "문제11724 - 연결 요소의 개수접근파이썬에서 input을 사용해서 입력을 받으면, 입력이 많을 때 시간초과가 뜬다….sys를 애용하자.코드 파이썬 코드from collections import dequeimport sysn, m = map(int, sys.stdin.readline().split())adj = [[] for _ in range(n+1)]visit = [0] * (n+1)for i in range(m): a, b = map(int, sys.stdin.readline().split()) adj[a]..." }, { "title": "[알고리즘] 백준 1260 - DFS와 BFS", "url": "/posts/BOJ8/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, DFS와 BFS, DFS, BFS", "date": "2021-04-10 23:00:00 +0900", "snippet": "문제1260 - DFS와 BFS접근DFS, BFS를 구현하기만 하면 되므로 설명은 따로 하지 않겠다.코드 파이썬 코드from collections import dequen, m, v = map(int, input().split(&#39; &#39;))adj = [[0]*(n+1) for _ in range(n+1)]visit = [0] * (n+1)for i in range(m): a, b = map(int, input().split(&#39; &#39;)) adj[a][b] = adj[b][a] = 1def df..." }, { "title": "[알고리즘] 백준 10265 - MT", "url": "/posts/BOJ7/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, MT, DFS, Cycle, DP", "date": "2021-04-10 23:00:00 +0900", "snippet": "문제10265 - MT접근정말 어려운 문제였다.앞에서 텀 프로젝트 문제를 푼 것이 크게 도움이 되었고, 해당 내용을 많이 사용하였다.크게 두 단계로 구성된다.첫 번째는 사이클을 검사하는 단계이다.이 단계에서는 텀 프로젝트의 접근법을 기반으로 하여 조금만 추가하였다.사이클에서 제외된 인원의 수를 구하는 것에 추가적으로 사이클을 구성하는 인원의 수도 구해주었다.두 번째는 검출한 사이클들을 바탕으로 DP를 수행하는 단계이다.DP는 배낭 문제와 거의 동일하다.사이클의 수가 i, 탑승가능 인원이 j라고 할 때 DP의 구성은 다음과 같다..." }, { "title": "[알고리즘] 백준 9466 - 텀 프로젝트", "url": "/posts/BOJ6/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 텀 프로젝트, DFS, Cycle", "date": "2021-04-10 23:00:00 +0900", "snippet": "문제9466 - 텀 프로젝트접근알고리즘을 생각하기까지가 굉장히 어려웠다.단순히 사이클을 검사하는 것을 넘어서, 사이클을 구성하는 노드들을 제외한 노드를 어떻게 찾을지 많이 고민했다.특정 노드에 대해서 dfs를 수행하면서, 방문하는 노드들을 배열에 모두 담아두고 있는다. (반드시 순서대로!)dfs를 수행하는 도중에 이미 방문한 노드가 등장한다면, 담아두었던 배열에서 해당 노드를 찾으면 된다!예를 들어, 현재 방문 배열이 (1, 2, 4, 7) 이었다고 생각해보자.그리고 4번 노드를 다시 왔다면, (4, 7)은 사이클을 이루고 있..." }, { "title": "[알고리즘] 백준 10552 - DOM", "url": "/posts/BOJ5/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, DOM", "date": "2021-04-09 23:00:00 +0900", "snippet": "문제10552 - DOM접근이 문제의 핵심은 크게 두 가지이다.첫 번째는 사이클이 생기는지 여부를 파악하는 것이다.채널을 계속돌릴 때 사이클이 발생했다면, 즉시 중단하고 -1을 출력해야 한다.두 번째는 현재 채널을 싫어하는 사람이 없는지 체크하는 부분이다.이는 채널이 돌아갈 때마다 체크를 해주어야 한다.입력 범위가 제법 크기 때문에, 효율적으로 처리해주지 못한다면 굉장히 오래걸릴 것이다.나는 딕셔너리를 사용하여 O(1) 시간에 체크할 수 있도록 했다.싫어하는 채널로 Key를, 싫어하는 사람을 Value로 구성하였다.만약 싫어하..." }, { "title": "[알고리즘] 백준 2468 - 안전 영역", "url": "/posts/BOJ4/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 안전 영역", "date": "2021-04-09 23:00:00 +0900", "snippet": "문제2468 - 안전 영역접근강수량을 x라고 할 때, board에 x 이하인 칸들은 막혀있다고 생각하면 간단해진다.그러면 열린 공간들의 개수를 세는 문제인데, 모든 강수량에 대해서 이를 반복해주면 된다.나는 입력을 받을 때, 최대 높이를 구해두고, 강수량을 1부터 최대 높이까지 반복하며 영역의 개수를 구해주었다.코드 파이썬 코드from collections import dequen = int(input())dx = [0,0,-1,1]dy = [-1,1,0,0]board = []maxRain = 0for i in range(n..." }, { "title": "[알고리즘] 백준 11403 - 경로 찾기", "url": "/posts/BOJ3/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 경로 찾기", "date": "2021-04-09 23:00:00 +0900", "snippet": "문제11403 - 경로 찾기접근특정 노드 a, b 가 있을 때, a와 b가 연결되어 있는지 확인하는 문제이다.이 때 a, b가 바로 연결되어 있다면 문제가 없겠지만, (a, k), (k, b)로 중간 노드를 거치는 경우를 어떻게 해결할지가 관건이다.나는 모든 노드 k에 대해 반복문을 돌며 k를 중간 지점으로 가지는 노드들에 대해 확인해주었다.코드 파이썬 코드n = int(input())arr = []for i in range(n): tmp = [int(i) for i in input().split()] arr.ap..." }, { "title": "[알고리즘] 프로그래머스 - 가장 먼 노드", "url": "/posts/Algorithm130/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 가장 먼 노드, BFS", "date": "2021-02-08 11:00:00 +0900", "snippet": "문제가장 먼 노드접근1번 노드에서부터 각 노드까지의 거리를 구하면 된다.따로 가중치가 없으므로 단순하게 BFS를 돌며 몇 번만에 도달했는지만 확인하면 된다.코드 파이썬 코드def solution(n, edge): answer = 0 dis = [-1] * (n+1) e = {} for i in range(1,n+1): e[i] = set() for a, b in edge: e[a].add(b) e[b].add(a) stack = [1] dis[1] =..." }, { "title": "[알고리즘] 프로그래머스 - 신규 아이디 추천", "url": "/posts/Algorithm129/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 신규 아이디 추천", "date": "2021-02-07 11:00:00 +0900", "snippet": "문제신규 아이디 추천접근그냥 문제에서 주어진 7단계를 순서대로 나열해서 풀었다.코드 파이썬 코드import redef solution(new_id): new_id = new_id.lower() new_id = re.findall(&#39;[a-z0-9\\.\\-\\_]&#39;,new_id) new_id = &#39;&#39;.join(new_id) cnt = 0 tmp = &#39;&#39; for item in new_id: if item == &#39;.&#39;: ..." }, { "title": "[알고리즘] 프로그래머스 - 순위", "url": "/posts/Algorithm128/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 순위, 그래프", "date": "2021-02-07 11:00:00 +0900", "snippet": "문제순위접근얼핏보고 위상 정렬인줄 알았다.위상 정렬로 풀려고 하다보니 쉽게 풀리지 않아서, 처음부터 다시 생각해보게된 문제.핵심은 A가 B를 이겼고, B가 C를 이겼다면 A도 C를 이긴셈이다.이 연결관계를 표현할 수 있어야한다.모든 연결 관계를 포함했을 때 A에게 진사람과 이긴 사람의 수가 n-1이면 순위를 표현할 수 있다.즉, 그래프로 따지면 이동거리가 2이상인 경우도 셀 수 있어야 한다.문제에서 주어진 결과로 딕셔너리 내에 집합을 만들어준다.그리고 해당 집합에 건너건너인 경우들을 추가해준다.코드 파이썬 코드def solu..." }, { "title": "[알고리즘] 프로그래머스 - 섬 연결하기", "url": "/posts/Algorithm127/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 섬 연결하기, 최소 스패닝 트리, MST, 프림", "date": "2021-02-02 11:00:00 +0900", "snippet": "문제섬 연결하기접근최소신장트리를 찾는 문제이다.주어진 그래프에서 최소 비용으로 트리를 만들면 된다.최소신장트리 알고리즘은 크루스칼, 프림 알고리즘이 있다.크루스칼 알고리즘의 경우 탐욕적으로 가장 가중치가 작은 간선들을 선택하며, 선택된 간선들만을 이용하여 노드들을 연결한다.이 때 사이클이 형성되는 것을 막기위해 연결된 노드들이 집합을 이루고 있을 때, 같은 집합에 속한 노드끼리는 연결하면 안된다.이를 위해 Union-find 알고리즘을 추가적으로 사용한다.프림 알고리즘의 경우 정점을 바탕으로 탐색하는 방법이다.기준 정점을 잡고..." }, { "title": "[알고리즘] 프로그래머스 - 거스름돈", "url": "/posts/Algorithm126/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 거스름돈, DP", "date": "2021-02-02 11:00:00 +0900", "snippet": "문제거스름돈접근DP 문제이다.n의 크기만큼, 그리고 화폐 종류만큼 미리 배열을 할당해준다.DP(x,y) 는 x번째 화폐까지 사용하여 y원을 만들 수 있는 경우의 수라하자.예제처럼 화폐 종류가 1,2,5가 있을 때, DP(2, 10)은 1,2원을 사용하여 10원을 만들 수 있는 경우의 수이다.이제 그럼 DP를 어떻게 계산해 나갈지 생각해보자.우선 DP(2, 1) 처럼 1,2 원을 사용하지만 만들고자하는 금액이 화페단위보다 작은 경우가 있다.이런 경우는 DP(1, 1)과 똑같은 결과를 가진다.이렇지 않은 경우에는 우선 x-1 번째..." }, { "title": "[알고리즘] 프로그래머스 - 단어 변환", "url": "/posts/Algorithm125/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 단어 변환", "date": "2021-02-01 11:00:00 +0900", "snippet": "문제단어 변환접근변환 가능한 단어의 경로를 따라가면서 target에 가장 빨리 도달하는 방법을 찾는 문제이다.BFS 알고리즘을 이용하면 쉽게 탐색 가능하다.아예 전처리해서 그래프 형식으로 만들어놓고 탐색할까 하다가 그렇게까지 안해도 될거같아서,그냥 단어 전체를 보며 다음 경우의 수를 탐색했다.isConvertPossible 함수는 주어진 두 개의 단어가 변환가능한 단어인지 확인하는 함수이다.이 때, 내 코드의 특성상 주어지는 두 단어가 같을 수도 있다.따라서 같은 경우 굳이 변환할 필요가 없으므로, False로 처리해주었다.현..." }, { "title": "[알고리즘] 프로그래머스 - 입국심사", "url": "/posts/Algorithm124/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 입국심사, 이분탐색", "date": "2021-02-01 11:00:00 +0900", "snippet": "문제입국심사접근이 문제도 이분탐색 문제이다.제한 사항을 보면 범위가 매우 큰 걸 볼 수 있는데, 이런 경우 일반적으로 완전탐색처럼 전체를 본다는 생각을 버려야 한다.이 경우에는 특정 시간이 t가 있을 때, 해당 시간에 모든 심사자가 심사를 받을 수 있는지 판단할 수 있으면 된다.그럼 모두 심사를 받을 수 있는 t 중에 최소값을 찾으면 된다.이 때 t를 이분탐색으로 줄여나간다면 쉽게 정답을 찾을 수 있다.코드 파이썬 코드def solution(n, times): start = 1 end = n * min(times)..." }, { "title": "[알고리즘] 프로그래머스 - 기지국 설치", "url": "/posts/Algorithm123/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 기지국 설치", "date": "2021-01-31 11:00:00 +0900", "snippet": "문제기지국 설치접근station의 위치가 정렬된 채로 들어오기 때문에 따로 전처리 해줄 필요는 없다.우선 전파의 거리 range를 구해놓자.자기 자신과 좌, 우로 전달되므로 range = w * 2 + 1 이 될 것이다.이제 정렬된 스테이션을 하나씩 보면,station의 위치를 x라고 하면 처음은 1번 아파트부터 x-w 아파트까지는 전파가 들어오지 않을 것이다.이 범위에 range가 몇 번들어가면 될지 계산해주면된다.그리고 시작 위치를 x+w로 옮겨주고 같은 작업을 반복하면된다.그리고 마지막 station까지 검사했다면 이제 ..." }, { "title": "[알고리즘] 프로그래머스 - 이중우선순위큐", "url": "/posts/Algorithm122/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 이중우선순위큐", "date": "2021-01-31 11:00:00 +0900", "snippet": "문제이중우선순위큐접근heap을 이용하는게 정석이겠지만, 그냥 리스트를 이용해도 괜찮다.코드 파이썬 코드def solution(operations): pq = [] for operation in operations: command, num = operation.split(&#39; &#39;) if command == &#39;I&#39;: pq.append(int(num)) else: if len(pq): if ..." }, { "title": "[알고리즘] 프로그래머스 - 최고의 집합", "url": "/posts/Algorithm121/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 최고의 집합", "date": "2021-01-31 11:00:00 +0900", "snippet": "문제최고의 집합접근원소들의 곱의 최대는 각 원소의 크기를 고르게 키워줘야 한다.즉 주어지는 수 s를 n으로 나눈 몫 이상을 모든 원소가 가졌을 때가 가장 크다.따라서, 기본적으로 몫을 모든 원소가 가진채로 나머지를 각 원소에 한개씩 더해준다.코드 파이썬 코드def solution(n, s): answer = [] divisor = s // n re = s % n if divisor == 0: return [-1] for i in range(n): if n - i &amp;g..." }, { "title": "[알고리즘] 프로그래머스 - 단속카메라", "url": "/posts/Algorithm120/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 단속카메라", "date": "2021-01-31 11:00:00 +0900", "snippet": "문제단속카메라접근진입 지점 혹은 진출 지점 중 하나를 기준으로 놓고 문제를 풀면된다.나는 진입 지점을 기준으로 잡고 진입 지점으로 정렬해주었다.가장 늦게 진입한 차의 진입점에 카메라를 설치하고, 해당 카메라와 만나는 차들을 모두 제거한다.남는 차중 가장 늦게 진입한 차의 진입점에 또 카메라를 설치하고, 차가 안남을 때까지 반복해주면 된다.코드 파이썬 코드def solution(routes): answer = 0 routes.sort(key = lambda x:-x[0]) print(routes) whil..." }, { "title": "[알고리즘] 프로그래머스 - 길 찾기 게임", "url": "/posts/Algorithm119/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 가장 먼 노드, 길 찾기 게임, 트리 순회", "date": "2021-01-31 11:00:00 +0900", "snippet": "문제길 찾기 게임접근문제를 최대한 꼼꼼히 읽고, 정확히 이해하는게 얼마나 중요한지 알게된 문제이다.전위, 후위 순회는 쉽지만, 주어진 정보들로 어떻게 트리를 만드느냐가 관건이다.문제를 다풀고 찾아보니 굉장히 간결하게 트리를 만들어내는 고수분들이 정말 많은 것 같다..나는 그냥 정석대로 만들었다.루트 노드를 붙이고, 크기를 비교하며 하나씩 내려오며 노드들을 이어갔다.편하게 하려면 트리를 만들기 전에 데이터를 정렬해줄 필요가 있다.y를 내림차순으로 정렬해주고, 그 안에서 x를 오름차순으로 정렬해주면 순서대로 돌면서 한번에 트리를 ..." }, { "title": "[알고리즘] 프로그래머스 - 징검다리 건너기", "url": "/posts/Algorithm118/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 징검다리 건너기, 이분 탐색", "date": "2021-01-31 11:00:00 +0900", "snippet": "문제징검다리 건너기접근그냥 풀었다가 시간초과가 났다.1명씩 건너보는 방법으로는 제시간에 풀 수 없다.특정 x명이 건널 수 있는지 없는지 판단하는 것에 O(n)의 시간이 걸린다.그럼 x를 조절하면서 건널 수 있는 최대값을 찾는 문제가 되는데,이는 이분 탐색을 이용하면 건널 수 있는 최대 x를 찾는 시간은 O(logn)의 시간이 필요하다. 최종적으로 O(nlogn)이 걸리므로 가능할 것 같다.범위는 최소 1명은 건널 수 있으니 1부터 시작하여 최대 가능한 인원은 돌의 크기중 최대값이다.예를 들어 최대값이 10이고 모든 돌이 10으..." }, { "title": "[알고리즘] 프로그래머스 - 보석 쇼핑", "url": "/posts/Algorithm117/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 보석 쇼핑, 투포인터", "date": "2021-01-30 11:00:00 +0900", "snippet": "문제보석 쇼핑접근처음에 방향을 잘못 잡아서 조금 돌아갔다.시작과 끝쪽에 포인터를 하나씩 두고 이동한다면 O(n) 안에 탐색할 수 있는 것 같다.투포인터 알고리즘이라고 한다.우선 시작점 s와 끝점 e를 모두 0에 둔다.e를 하나씩 옮기며 해당 점에 있는 보석을 담아준다.모든 종류의 보석이 담기면 이제 s을 하나씩 이동하며 해당 점의 보석을 빼준다.이 때 해당 보석을 뺏을 때 모든 보석 종류가 유지되지 않는 순간이 0~e 까지중 최소 구간이 된다.정확히는 해당 지점의 보석이 1개가 되는 순간 그 보석을 제거하면 모든 종류를 유지할..." }, { "title": "[알고리즘] 프로그래머스 - 숫자 게임", "url": "/posts/Algorithm116/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 숫자 게임", "date": "2021-01-30 11:00:00 +0900", "snippet": "문제숫자 게임접근두 배열을 정렬해놓고 문제를 풀면 쉬워진다.현재 배열에서 가장 큰 값끼리 비교를 하고, B가 더 크다면 두 최대값을 없애고 승점을 1점 올린다.만약 작다면, B의 최대값은 승리를 위해 아껴두고, 최소값을 이용해서 패배한다고 생각하면 된다.실제 구현에서 최소값을 사용하여 패배할 필요는 없다.어떤 경우든 A의 최대값은 계속 지워나가므로, A의 크기만큼 돌고나면 끝나기 때문이다.코드 파이썬 코드def solution(A, B): A.sort(reverse=True) B.sort(reverse=True) ..." }, { "title": "[알고리즘] 프로그래머스 - 베스트앨범", "url": "/posts/Algorithm115/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 베스트앨범", "date": "2021-01-30 11:00:00 +0900", "snippet": "문제베스트앨범접근해시 문제이다.우선 장르별 재생횟수를 통합해주는 딕셔너리 gen_cnt를 만들자.gen_cnt는 각 장르 이름을 key로 가지며, 재생횟수를 value로 가진다.재생횟수로 정렬해서 어떤 장르를 먼저 뽑을지 만들어놓는다.gen_rank에 정렬된 딕셔너리가 담기며,이제 이를 바탕으로 각 장르별로 노래와 트랙을 리스트로 넣어준다.특정 장르의 리스트를 가져와서 정렬해준다.그리고 상위에 2개 혹은 노래가 한개뿐이라면 1개를 정답에 담아준다.코드 파이썬 코드import operatordef solution(genres,..." }, { "title": "[알고리즘] 프로그래머스 - 정수 삼각형", "url": "/posts/Algorithm114/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 정수 삼각형, DP", "date": "2021-01-29 11:00:00 +0900", "snippet": "문제정수 삼각형접근동적계획법이라면 동적계획법인 문제이다.꼭대기에서 시작해서 아래로 내려가면서 현재 위치에서 가장 큰값을 찾으면된다.좌,우 끝부분은 자기자신에 바로 위를 더하면 되고,중앙에 위치한 부분들은 자기와 연결된 위에 둘 중 큰값을 더해주면 된다.코드 파이썬 코드def solution(triangle): for i in range(len(triangle)): if i == 0: continue for j in range(len(triangle[i])): ..." }, { "title": "[알고리즘] 프로그래머스 - 네트워크", "url": "/posts/Algorithm113/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 네트워크, BFS", "date": "2021-01-29 11:00:00 +0900", "snippet": "문제네트워크접근간단한 BFS 문제이다.코드 파이썬 코드def solution(n, computers): visit = [0] * n answer = 0 for i in range(n): if visit[i] == 0: visit[i] = 1 bfs(i, visit, computers) answer+=1 return answerdef bfs(i, visit, computers): queue = [] queue.append(i..." }, { "title": "[알고리즘] 프로그래머스 - 풍선 터트리기", "url": "/posts/Algorithm112/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 풍선 터트리기, DP", "date": "2021-01-29 11:00:00 +0900", "snippet": "문제풍선 터트리기접근최초 접근 방법은 최후까지 남는지 확인할 풍선이 i 번째 풍선이라면,i 번째를 기준으로 좌,우로 나누어 확인하고자 했다.왼쪽에서 최소값과 오른쪽에서 최소값을 구했을 때, i번째의 값이 이 3개의 값 중 가장 크다면,무슨 수를 써도 살아남을 수 없다.번호가 더 작은 풍선은 한번만 터트릴 수 있기 때문!또한 가장자리의 값, 즉 가장 앞과 뒤의 값은 무조건 살아남을 수 있을 것이다.곰곰히 생각해보니 이 방법이 맞는거 같았다.모든 경우에도 틀리지 않는다.그런데 문제는 시간초과가 났다.아무래도 배열의 길이가 너무 길..." }, { "title": "[프로그래머스 인공지능스쿨] Week8-5 Deep Learning: 순환신경망 - RNN", "url": "/posts/Day30/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-29 00:00:00 +0900", "snippet": "강의시계열 데이터(Time series data)특징들이 순서를 가지기 때문에, 단순히 공간적인 측면이외에도, 순서에 따른 특징이 중요함시계열 데이터는 보통 동적이며 길이가 가변적임$$RNN(Recurrent neural networks)RNN은 시계열 정보를 처리하는데 효과적인 학습 모델이다.매우 긴 시계열 데이터를 처리할 때는, 장기 의존성(long term dependency)를 잘 다룰 수 있는 LSTM을 주로 사용한다.최근에는 순환 신경망도 생성 모델로 사용하기도 한다.\\(\\rhd\\) RNN 필수 요소 시간성 : 특..." }, { "title": "운영체제 정리 3 - 병행성", "url": "/posts/OSCourse3/", "categories": "IT, OS", "tags": "IT, OS, Operation Systems", "date": "2021-01-28 21:20:00 +0900", "snippet": "Contents 병행성(Concurrency) \\(\\rhd\\)경쟁 상태(Race Condition) \\(\\rhd\\)임계 자원(Critical Resource)과 임계 영역(Critical Section) \\(\\rhd\\)상호 배제(Mutual exclusion) \\(\\rhd\\)상호 배제 기법 \\(\\rhd\\)교착 상태(Deadlock) \\(\\rhd\\)교착 상태 해결 기법 \\(\\rhd\\)기아(Starvation) 병행성(Concurrency)운영체제의 ..." }, { "title": "운영체제 정리 2 - 프로세스, 스레드, 병행성", "url": "/posts/OSCourse2/", "categories": "IT, OS", "tags": "IT, OS, Operation Systems", "date": "2021-01-28 21:20:00 +0900", "snippet": "Contents 프로세스(Process) \\(\\rhd\\)프로세스란? \\(\\rhd\\)Dispatcher \\(\\rhd\\)프로세스 5-상태 모델 스레드(Thread) \\(\\rhd\\)스레드란? \\(\\rhd\\)멀티스레딩(Multithreading) 프로세스(Process)\\(\\rhd\\)프로세스란?프로세스란 간단히 말해서 컴퓨터 상에서 실행중인 프로그램을 의미한다.프로세스의 두 필수적인 요소는 프로그램 코드와 언계된 데이터 집합이다.프로세스는 운영체제로부터..." }, { "title": "[프로그래머스 인공지능스쿨] Week8-4 Deep Learning: 최적화 (2)", "url": "/posts/Day29/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-28 00:00:00 +0900", "snippet": "강의활성 함수(Activation function)각 layer들을 거치면서 수행하는 연산들은 모두 선형적인 연산이다.이러한 선형적 연산에 비선형적인 연산을 추가하기 위해 각 layer의 연산결과에 비선형 활성함수를 적용한다.\\(\\rhd\\) SigmoidSigmoid 활성화 함수는 0, 1 사이의 값을 가지도록 설계되어 있다.초기 신경망들에서 많이 사용했지만, 최근에는 Sigmoid가 가지는 단점들 때문에 학습에 거의 사용하지 않는다.가장 큰 문제는 역전파 과정은 결국 미분을 한 값을 전달한다.이 때 sigmoid 함수의 미분..." }, { "title": "운영체제 정리 1 - 개요", "url": "/posts/OSCourse1/", "categories": "IT, OS", "tags": "IT, OS, Operation Systems", "date": "2021-01-27 21:20:00 +0900", "snippet": "Contents 컴퓨터 시스템 기본 구성요소 제어 및 상태 레지스터(Control and Status Registers) 명령어 수행 사이클 Interrupts \\(\\rhd\\) 인터럽트 종류 \\(\\rhd\\) 인터럽트를 포함한 명령어 사이클 \\(\\rhd\\) 인터럽트 처리 과정 메모리 계층 구조(Memory hierarchy) 캐시 메모리(Cache Memory) 운영체..." }, { "title": "[프로그래머스 인공지능스쿨] Week8-3 Deep Learning: 최적화 (1)", "url": "/posts/Day28/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-27 00:00:00 +0900", "snippet": "강의데이터 전처리꼭 해야하는 것은 아니지만, 데이터에 따라 전처리를 적용했을 때 효과가 더 좋을 수도 있다.\\(\\rhd\\) Scale 문제각 feature에 따라 값의 차이가 크거나, 작을 수 있다.예를 들어 첫 번째 특징은 최대 20정도의 차이가 나고, 두 번째 특징은 0.3 정도의 차이가 난다고 하자.이때 각 특징의 scale에 따라서 학습 속도가 크게 차이가 난다.이를 방지하기 위해 데이터의 Scale을 비슷하게 맞춰주는 전처리를 진행한다.두 번째로 모든 데이터가 양수인 경우에 발생하는 문제이다.학습과정에서 극단적인 상황..." }, { "title": "[프로그래머스 인공지능스쿨] Week8-3 Deep Learning: 최적화 - 손실함수", "url": "/posts/Day27/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-27 00:00:00 +0900", "snippet": "강의학습을 마친 후, 실생활에서 발생하는 새로운 샘플들도 잘 예측할 수 있어야 한다.즉, 일반화하는 능력이 좋아야한다.이러기 위한 다양한 최적화 방법을 알아보자.손실 함수\\(\\rhd\\) 평균 제곱 오차(MSE: Mean Square Error)\\[e = \\frac{1}{2}\\parallel y - o\\parallel_{2}^{2}\\]y는 실제 결과, o는 출력값이다.오차(e)가 클수록 가중치와 편향을 더 크게 교정해준다.하지만 wx+b가 커지면, 경사도가 작아지기 때문에 오차가 큰 상황에서도 더 적게 교정을하는 문제가 있다.\\..." }, { "title": "[프로그래머스 인공지능스쿨] Week8-2 Deep Learning: 신경망 기초 - 생성모델", "url": "/posts/Day26/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-27 00:00:00 +0900", "snippet": "강의생성 모델\\(\\rhd\\) 생성 모델이란기존 분별 모델의 경우, x가 주어졌을 때 y, 즉 라벨값을 예측하는 문제이다.생성 모델의 경우 그보다 더 나아가 궁극적으로 x, 즉 데이터 자체를 생성하고, 데이터로부터 y값이 어떻게 추정되는지에 관한 문제이다.\\(\\rhd\\) 선형대수샘플(데이터)를 특징 벡터(feature vector)로 표현 벡터의 내적백터의 내적은 결국 두 벡터 사이의 유사도를 나타낸다.내적의 결과가 90도보다 작으면 0보다 큰값을 가지며,90도 이면 0, 90도 보다 크면 음수를 가진다.신경망의 학습은 결국 ..." }, { "title": "[프로그래머스 인공지능스쿨] Week8-1 Deep Learning: 신경망 기초 - MLP, CNN", "url": "/posts/Day25/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-26 00:00:00 +0900", "snippet": "강의Deep Leraning: 다층 퍼셉트론\\(\\rhd\\) 초기 핵심 아이디어 은닉층은닉층을 두어, 원래 특징 공간을 분류하는데 훨씬 유리한 새로운 특징 공간으로 변환 Sigmoid 활성 함수 도입출력값을 연속값으로 만들어주어, 융툥성있는 의사결정을 가능하게 만듬 오류 역전파 알고리즘(back propagation)역방향으로 진행하며, 한 번에 한 층씩 그레디언트를 계산하고 가중치를 갱신한다.CNN영상 인식 분야에 특화되어 있는 모델영상, 음성 등 격자(grid) 구조를 가지는 데이터에 적합하다.\\(\\rhd\\) 영상 인식..." }, { "title": "[프로그래머스 인공지능스쿨] Week7-2 Deep Learning: 신경망 기초 - 수학", "url": "/posts/Day24/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-22 00:00:00 +0900", "snippet": "강의Deep Leraning: 수학\\(\\rhd\\) 수학의 역할수학은 학습모델의 목적함수를 정의하고, 이 목적함수의 최저점을 찾아주는 최적화 이론을 제공한다.\\(\\rhd\\) 선형대수샘플(데이터)를 특징 벡터(feature vector)로 표현 벡터의 내적백터의 내적은 결국 두 벡터 사이의 유사도를 나타낸다.내적의 결과가 90도보다 작으면 0보다 큰값을 가지며,90도 이면 0, 90도 보다 크면 음수를 가진다.신경망의 학습은 결국 벡터의 내적을 통하여 공간을 변화시킨다.\\(\\rhd\\) 확률과 통계기계 학습이 처리할 데이터는 불확..." }, { "title": "[프로그래머스 인공지능스쿨] Week7-1 Deep Learning: 신경망 기초 - 기계학습", "url": "/posts/Day23/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-21 00:00:00 +0900", "snippet": "강의Deep Leraning: 기초\\(\\rhd\\) Overfitting, Underfitting Underfitting주어진 모델이 데이터를 학습하기에 너무 부족한 성능을 보이는 경우모델의 용량, 즉 자유도가 작기때문에 오차가 클 수 밖에 없는 경우이다.이 경우 해결책은 모델의 자유도를 증가, 즉 모델의 파라미터를 늘려주면 해결할 수 있다. OverfittingUnderfitting과 반대로 주어진 데이터에 비해 모델의 성능이 너무 좋은 경우 발생한다.학습데이터를 너무 과도하게 학습하여, 학습데이터에 한해서는 좋은 성능을 ..." }, { "title": "[알고리즘] 프로그래머스 - 멀리 뛰기", "url": "/posts/Algorithm111/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 멀리 뛰기, DP", "date": "2021-01-19 11:00:00 +0900", "snippet": "문제멀리 뛰기접근DP문제이다.접근법은 타일링문제와 똑같다.n칸의 경우의 수는 n-1칸에서 1칸으로 뛰는 방법 + n-2에서 두칸으로 뛰는방법이다.코드 파이썬 코드def solution(n): dp = [0] * (n+1) dp[0] = 1 dp[1] = 1 for i in range(2, n+1): dp[i] = (dp[i-1] + dp[i-2])%1234567 return dp[n] " }, { "title": "[알고리즘] 프로그래머스 - [3차] 파일명 정렬", "url": "/posts/Algorithm110/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 파일명 정렬", "date": "2021-01-19 11:00:00 +0900", "snippet": "문제[3차] 파일명 정렬접근문제에서 주어진대로 HEAD, NUMBER, TAIL을 분리해준다.lambda를 이용하여 정렬해주고, 출력한다.코드 파이썬 코드def solution(files): answer = [] file = seperateFile(files) f = sorted(file, key = lambda x: (x[0], x[1])) for i in f: answer.append(i[3]) return answerdef seperateFile(files): sepFile ..." }, { "title": "[알고리즘] 프로그래머스 - [3차] 방금그곡", "url": "/posts/Algorithm109/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 방금그곡", "date": "2021-01-19 11:00:00 +0900", "snippet": "문제[3차] 방금그곡접근시간에 따라 곡이 반복될 수도 있고, 잘릴 수도 있다.편하게 하기 위해서는 해당 곡의 풀 버전을 구해야 한다.잘리면 잘리는 버전, 반복되면 반복되는 버전을 구해서 그것과 m을 비교해주면 된다.이를 위해 calcPlayTime 함수는 시작 시간과 종료 시간을 입력 받아 분 단위의 플레이 시간을 반환한다.musicFullTimeVer 함수는 플레이 시간을 이용하여 곡의 풀버전을 만들어 반환한다.이 때 사용되는 음이 C# 등 두 자리인 것들을 변환해주고 진행해야 한다.converseMusic 함수는 #이 붙은..." }, { "title": "[알고리즘] 프로그래머스 - 오픈채팅방", "url": "/posts/Algorithm108/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 오픈채팅방", "date": "2021-01-19 11:00:00 +0900", "snippet": "문제오픈채팅방접근닉네임은 계속 바뀔 수 있지만, ID는 바뀌지 않는다.ID : 닉네임으로 딕셔너리를 만들고, 닉네임을 변경할 때마다 반영해놓는다.최종적인 닉네임을 가지고 출력 형식에 맞게 출력해주면 된다.코드 파이썬 코드def solution(record): answer = [] dic = {} order = [] for item in record: l = item.split(&#39; &#39;) if l[0] == &#39;Enter&#39;: dic[l[..." }, { "title": "[알고리즘] 프로그래머스 - [1차] 뉴스 클러스터링", "url": "/posts/Algorithm107/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 뉴스 클러스터링, 집합", "date": "2021-01-19 11:00:00 +0900", "snippet": "문제[1차] 뉴스 클러스터링접근다중 집합을 어떻게 구현할지 막막했다.set()을 이용하고 싶은데, set은 중복이 허용안되서 어떻게 할지 고민하다가,그냥 하나씩 카운트해주기로 했다.우선 주어지는 문자열을 2글자씩 짤라서 리스트로 저장한다.그리고 집합을 이용해서 교집합과 합집합을 구한다.이제 마지막으로 교집합과 합집합의 원소개수를 구해서 유사도 연산을 해야하는데,중복된 값을 모두 제거해버렸으니, 하나씩 다시 계산한다.각 리스트에 집합의 원소를 몇개씩 가지고 있는지 세서 더해준다.합집합의 경우 더 많이 가지고 있는 쪽을 따르고, ..." }, { "title": "[알고리즘] 프로그래머스 - 괄호 변환", "url": "/posts/Algorithm106/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 괄호 변환", "date": "2021-01-19 11:00:00 +0900", "snippet": "문제괄호 변환접근함수를 하나만들고 문제에서 주어지는 그대로 코드로 옮기면 된다.문제가 조금 복잡해보여서 헷갈리지 않게 필요한 부분들을 모두 함수화시켰다.converse가 재귀를 담당하는 메인 함수,balenceStr은 문제에서 2번 균형잡힌 괄호 문자열 u, v로 분리하는 함수,isRightStr은 문제에서 3,4번의 기준인 u가 올바른 괄호 문자열인지 판단하는 함수,reverseStr은 문제에서 4-4번 u의 괄호 방향을 바꾸는 함수이다.코드 파이썬 코드def solution(p): answer = converse(p..." }, { "title": "[알고리즘] 프로그래머스 - [1차] 캐시", "url": "/posts/Algorithm105/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 캐시", "date": "2021-01-19 11:00:00 +0900", "snippet": "문제[1차]캐시접근캐시 배열을 하나만들어두고, 정말 LRU 알고리즘을 하듯이 구현해야한다.LRU 알고리즘은 가장 오래동안 참조되지 않은 페이지를 교체하는 알고리즘이다.이를 위해서는 해당 페이지가 언제 참조되었는지를 기록해주어야 한다.최근 참조를 1부터 시작해서 나아간다면, 페이지가 바뀔때마다 나머지 캐시에 있는 페이지들을 모두 +1씩 해주어야하는 번거로움이 있으므로,그냥 time 이라는 변수를 만들어 캐시에 접근 할때마다 +1일 더해서 이 값을 그대로 써주었다.이렇게 구현하면 time은 계속 늘어나므로, 가장 time값이 작은..." }, { "title": "[알고리즘] 프로그래머스 - 수식 최대화", "url": "/posts/Algorithm104/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 수식 최대화", "date": "2021-01-19 11:00:00 +0900", "snippet": "문제수식 최대화접근처음에 생각했던 것보다 복잡했다.우선 입력값을 전처리하여 숫자와 수식으로 나눈다.그 다음 주어진 수식에 대한 조합을 찾는다.각 조합별로 수식을 연산한다.코드 파이썬 코드from itertools import permutationsdef solution(expression): s = set() num = [] cal = [] numStr = &#39;&#39; for e in expression: if e == &#39;-&#39; or e == &#39;+&#39; o..." }, { "title": "[알고리즘] 프로그래머스 - 주식가격", "url": "/posts/Algorithm99/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-18 20:00:00 +0900", "snippet": "문제주식가격접근스택 문제이다.스택 최상단보다 큰 값이 나오면 작아질 때까지 스택에서 빼주면서 인덱스를 계산해준다.모든 값을 스택에 추가한 후에는 스택에 얼마나 들어있었는지를 계산해주면 된다.코드 파이썬 코드def solution(prices): answer = [0] * len(prices) stack = [] for i in range(len(prices)): while True: if len(stack) == 0 or prices[i] &amp;gt;= prices[stac..." }, { "title": "[알고리즘] 프로그래머스 - 프린터", "url": "/posts/Algorithm98/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-18 20:00:00 +0900", "snippet": "문제프린터접근큐, 힙 문제이다.프린터 자체는 큐로 구현하고, 우선순위를 최대 힙으로 구현해놓으면 편하게 풀 수 있다.힙에서 가장 상단과 현재 큐의 상단을 비교하여 같으면 빼고 다르면 큐에 다시 삽입하는 식이다.따로 큐나 힙을 쓰진 않았고 list를 이용해 구현했다.pq가 힙의 역할을 한다.코드 파이썬 코드def solution(priorities, location): answer = 0 pq = priorities[:] pq.sort() while True: if pq[-1]==priorit..." }, { "title": "[알고리즘] 프로그래머스 - 타겟 넘버", "url": "/posts/Algorithm102/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 타겟 넘버", "date": "2021-01-18 20:00:00 +0900", "snippet": "문제타겟 넘버접근완전 탐색밖에 방법이 없는 것 같다.각 숫자를 더하는 경우와 빼는 경우 두가지를 모두 확인해주면 된다. 코드 파이썬 코드def solution(numbers, target): answer = bf(numbers, 0, target, 0) return answerdef bf(numbers, idx, target, sumNum): if idx == len(numbers): if sumNum == target: return 1 else: ..." }, { "title": "[알고리즘] 프로그래머스 - JadenCase 문자열 만들기", "url": "/posts/Algorithm101/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-18 20:00:00 +0900", "snippet": "문제JadenCase 문자열 만들기접근잘 처리해준 것 같은데 틀려서 반례를 찾느라 한참 걸린 것 같다.입력으로 공백문자만 주어지는 경우가 있었다.이 경우 원래 공백문자를 그대로 출력해줘야 하는 것 같다.split를 하지않고 한글자씩 읽으며 변환하는게 더 쉬울거 같기도하다.이미 시작을 이렇게 해서 바꾸긴 귀찮아서 그냥 했다.코드 파이썬 코드def solution(s): l = s.split(&#39; &#39;) answer = &#39;&#39; for item in l: if item == &#..." }, { "title": "[알고리즘] 프로그래머스 - 튜플", "url": "/posts/Algorithm100/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-18 20:00:00 +0900", "snippet": "문제튜플접근문자열을 잘 처리해주어야 한다.문자열에서 가장 앞, 뒤의 {{, }}를 제거해주고, “},{“를 기준으로 split해주면집합의 각 원소를 얻을 수 있다.원소의 길이를 기준으로 정렬해준다.이를 ,를 기준으로 다시 split해주면 하나하나의 숫자를 list에 담을 수 있다.이제 answer에 담기지 않은 숫자를 하나씩 순서대로 담아주면 된다.코드 파이썬 코드def solution(s): answer = [] s = s[2:-2] l = s.split(&#39;},{&#39;) l.sort(key=..." }, { "title": "[알고리즘] 프로그래머스 - 쿼드압축 후 개수 세기", "url": "/posts/Algorithm103/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, 알고리즘, 프로그래머스, 파이썬, 쿼드압축", "date": "2021-01-18 11:00:00 +0900", "snippet": "문제쿼드압축 후 개수 세기접근0과 1의 개수만 세면 되기 때문에,일반 적인 쿼드압축에서 배열을 유지하는 것과 다르게 0, 1의 개수만을 이용해봤다.코드 파이썬 코드def solution(arr): answer = [] n = len(arr) answer = quardTree(arr, 0, 0, n) return answerdef quardTree(arr, x, y, n): ans = [0,0] quard = [0,0]*4 if n == 1: ans[arr[y][x]]+=1 ..." }, { "title": "[알고리즘] 프로그래머스 - 가장 큰 정사각형 찾기", "url": "/posts/Algorithm97/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-17 20:00:00 +0900", "snippet": "문제가장 큰 정사각형 찾기접근DP 문제이다.왼쪽 위 부터 순서대로 배열을 탐색하며 현재 자리에서 정사각형을 만들수 있는지 판단하면 된다.판단 기준은 현재 자리가 1일 때, 왼쪽, 위, 왼쪽 위의 값 중 가장 작은 값에 +1을 한다.가장 작은 값이 0이라면 정사각형은 만들어질 수 없다.반면 가장 작은 값이 1이상이라면 정사각형이 성립하는 경우이다.1이라면 현재 위치에서 처음으로 정사각형이 이루어지므로 길이가 2인 정사각형이 된다.2이상이라면 이미 이전 위치에서 모두 2이상의 정사각형을 이루고 있었으므로, 현재 위치에서 3이상의 ..." }, { "title": "[알고리즘] 프로그래머스 - 다음 큰 숫자", "url": "/posts/Algorithm96/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-17 20:00:00 +0900", "snippet": "문제다음 큰 숫자접근파이썬의 내장함수를 많이 사용했다.2진수 변환은 bin(), format() 함수를 사용할 수 있다.나는 format()을 사용했으며, count() 함수를 이용하여 1의 개수를 센다.n부터 1씩 늘려가며 비교해주다가 같은게 나오면 그게 답이다.코드 파이썬 코드def solution(n): oneCnt = format(n,&#39;b&#39;).count(&#39;1&#39;) while True: n+=1 nxtCnt = format(n,&#39;b&#39;).coun..." }, { "title": "[알고리즘] 프로그래머스 - 땅따먹기", "url": "/posts/Algorithm95/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-17 20:00:00 +0900", "snippet": "문제땅따먹기접근DP 문제이다.n * 4의 배열을 만들어두고, 현재 열의 최대값을 4개 모두 구해준다.각 자리의 최대값은 현재 값 + 이전 열에서 현재 위치를 제외한 3개 중 최대값이다.i는 현재 열을 나타내며 j는 4칸중하나 즉, 0~3의 범위이다.\\[dp\\[i\\]\\[j\\] += max(dp\\[i-1\\]\\[j를 제외한 나머지\\])\\]최종 답은dp[n-1] 중 최대값이다.코드 파이썬 코드def solution(land): dp = land[:] for i in range(1, len(land)): for..." }, { "title": "[알고리즘] 프로그래머스 - [1차] 프렌즈4블록", "url": "/posts/Algorithm94/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-16 20:00:00 +0900", "snippet": "문제[1차] 프렌즈4블록접근크게 두단계로 이루어져 있다. 2x2 블록 찾기n x m 블록을 하나씩 검사하며 인접한 4개 블록이 같은지 검사한다.왼쪽 상단부터 검사를 시작하며 검사하는 블록 기준으로 오른쪽, 아래, 오른쪽 아래의 블록이 같은지 체크한다.이렇게 검사하면 중복된 곳은 검사하지 않는다.같다면 해당 블록의 숫자를 카운팅해준다.문제는 예제처럼 블록이 겹쳐있는 부분이다.이 경우에 중복 카운팅을 막기 위해서 checkboard를 두어 같은 곳은 체크를 하며 진행한다.checkboard는 다음 단계를 진행할 때 유용하게 쓰이..." }, { "title": "[알고리즘] 프로그래머스 - 소수 만들기", "url": "/posts/Algorithm93/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-16 20:00:00 +0900", "snippet": "문제소수 만들기접근주어지는 수 중 순서에 상관없이 3개를 뽑는 문제로, 완전 탐색 문제이다.소수를 미리 다 찾아두고 3개의 합이 소수인지 확인만 해주면 된다.코드 파이썬 코드dp = [1] * 3000def solution(nums): answer = -1 dp[0] = dp[1] = 0 for i in range(2, 3000): if dp[i] != 1: continue for j in range(i*2, 3000, i): dp[j] = 0 ..." }, { "title": "[알고리즘] 프로그래머스 - 올바른 괄호", "url": "/posts/Algorithm92/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-16 20:00:00 +0900", "snippet": "문제올바른 괄호접근가장 기본적인 stack을 활용한 괄호쌍 문제이다.코드 파이썬 코드def solution(s): answer = True stack = [] for item in s: if item == &#39;(&#39;: stack.append(1) else: if stack: stack.pop() else: answer = False br..." }, { "title": "[알고리즘] 프로그래머스 - 이진 변환 반복하기", "url": "/posts/Algorithm91/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-16 20:00:00 +0900", "snippet": "문제이진 변환 반복하기접근s에 1이 몇개 포함되어 있는지 확인해주면 된다.s의 길이 - 1의 개수만큼이 0의 개수이므로 한번 s를 변환할 때마다 0의 개수를 카운팅해서 더해주고,1의 개수로 다시 s를 생성한다.코드 파이썬 코드def solution(s): answer = [0,0] while s != &#39;1&#39;: oneCnt = 0 for item in s: if item == &#39;1&#39;: oneCnt+=1 a..." }, { "title": "[알고리즘] 프로그래머스 - 소수 찾기", "url": "/posts/Algorithm90/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-15 20:00:00 +0900", "snippet": "문제소수 찾기접근완전 탐색 문제이다.모든 조합을 확인해봐야 하는 것은 확실하다.그렇다면 확인하는데 걸리는 시간을 줄이는 방향으로 접근해야 할 것 같다.해당 조합으로 나올 수 있는 최대치까지 소수를 미리 찾아놓고, 해당 숫자의 index로 접근하는 식으로 구현한다면 소수인지 판별하는데 걸리는 시간은 O(1)으로 해결할 수 있다.단점은 메모리는 많이 잡아 먹을 것이다.모든 조합을 확인하는 방법은 재귀를 이용해 진행하는 것도 가능하며, 파이썬의 경우 permutations 을 이용하여 쉽게 연산이 가능하다.여기서는 연습을 위해 재귀..." }, { "title": "[알고리즘] 프로그래머스 - 삼각 달팽이", "url": "/posts/Algorithm89/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-15 20:00:00 +0900", "snippet": "문제삼각 달팽이접근삼각형 모양을 왼쪽으로 붙여서 배열로 생각해보자.칸을 채워나가는 방향은 세 가지 밖에 없다. 아래로 움직이는 경우 오른쪽으로 움직이는 경우 왼쪽 위방향 대각선으로 움직이는 경우세 가지 경우에 대해 각각 구현하면 된다.주의할 부분은 방향을 전환하는 경우가 다음 방향이 범위를 벗어나거나, 이미 칠해진 곳을 만날 때 두 가지를 고려해야한다.코드 파이썬 코드def solution(n): answer = [[0 for _ in range(n)] for _ in range(n)] sum = 0 f..." }, { "title": "[알고리즘] 프로그래머스 - [3차] n진수 게임", "url": "/posts/Algorithm88/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-15 20:00:00 +0900", "snippet": "문제[3차] n진수 게임접근10진수가 넘어가는 경우 진수 변환 과정에서 나머지가 10이 넘어갈 수 있다.이 경우에 아스키코드를 이용하여 변환 과정을 따로 처리해줘야 한다.코드 파이썬 코드def solution(n, t, m, p): answer = &#39;&#39; cnt = 0 num = 0 turn = 0 p-= 1 while cnt &amp;lt; t: transform = &#39;&#39; tmp = num if tmp == 0: ..." }, { "title": "[알고리즘] 프로그래머스 - 최댓값과 최솟값", "url": "/posts/Algorithm87/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-15 20:00:00 +0900", "snippet": "문제최댓값과 최솟값접근문자열 처리만 잘해주면 된다.코드 파이썬 코드def solution(s): s_list = list(s.split(&quot; &quot;)) l = [] for item in s_list: if item[0] == &#39;-&#39;: tmp = -1 * int(item[1:]) else: tmp = int(item[:]) l.append(tmp) l.sort() answer = str(l[0]) ..." }, { "title": "[알고리즘] 프로그래머스 - N개의 최소공배수", "url": "/posts/Algorithm86/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-07 20:00:00 +0900", "snippet": "문제N개의 최소공배수접근두 수의 최대 공배수를 구하는 방법은 간단하다.최대 공배수 = 두 수의 곱 / 최소 공약수최소 공약수는 유클리드 호제법을 이용하면 된다.그렇다면 여러 개의 숫자의 최대 공배수는 어떻게 구할까?복잡하게 생각할 것 없이, 최대 공배수를 n-1번 구해주면 된다.코드 파이썬 코드def solution(arr): arr.sort() answer = arr[0] for i in range(1,len(arr)): n = gcd(answer, arr[i]) answer = a..." }, { "title": "[알고리즘] 프로그래머스 - 멀쩡한 사각형", "url": "/posts/Algorithm85/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-07 20:00:00 +0900", "snippet": "문제멀쩡한 사각형접근규칙을 찾는데 생각보다 오랜 시간이 걸렸다.우선 w, h의 최대공약수만큼 패턴이 반복된다는 것은 쉽게 찾을 수 있었다.예제에서의 경우 8, 12의 최대공약수인 4회 패턴이 반복된다.결국 전체 수식은 다음과 같을 것이다.전체 사각형의 수 - (패턴에서 잘리는 사각형 * 최대공약수)문제는 패턴안에서 잘리는 사각형의 개수를 어떻게 찾을지이다.나는 1x1부터 4x3까지 직접 그려봤다..그리고 잘리는 사각형의 개수가 w+h-1이란 것을 발견했다.정확히는 모르겠지만 원점 부터 대각선 끝점까지 선을 그리면 가로의 개수와..." }, { "title": "[알고리즘] 프로그래머스 - 전화번호 목록", "url": "/posts/Algorithm84/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-07 20:00:00 +0900", "snippet": "문제전화번호 목록접근전화번호를 정렬한 후 시작하면 생각보다 간단한 문제가 된다.현재 번호가 바로 다음 번호의 접두사인지만 확인하면 되는 문제이다. 바로 다음 번호가 접두사가 아니라면, 나머지 번호들도 접두사가 아니다. 뒷 번호가 앞번호의 접두사가 되는 경우가 존재하지 않는다. 문자의 길이를 체크할 필요가 없다. 다음 번호의 접두사라면, 다음 번호보다 짧거나 같다. 다음 번호의 접두사가 아니라면, 현재 번호의 끝까지 확인하기 전에 다른 숫자가 나오게 된다. 코드 파이썬 코드def solu..." }, { "title": "[알고리즘] 프로그래머스 - 영어 끝말잇기", "url": "/posts/Algorithm83/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2021-01-07 20:00:00 +0900", "snippet": "문제영어 끝말잇기접근이전 단어의 마지막과 현재 단어의 시작이 같은지 여부와현재 단어가 이전에 나온적이 있는지만 체크해주면 된다.코드 파이썬 코드def solution(n, words): answer = [] word_set = set() loc = 0 turn = 1 now_word = words[0][0] for word in words: if word[0] == now_word[-1]: now_word = word beLen = len(w..." }, { "title": "[프로그래머스 인공지능스쿨] Monthly Project 1", "url": "/posts/MonthlyProject1/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-07 00:00:00 +0900", "snippet": "프로젝트 소개첫 번째 프로젝트는 데이터 분석 결과를 시각화하는 웹페이지를 개발하는 것이다.나는 그동안 배운 Python django를 이용하여 웹 어플리케이션을 개발할 것이다.주제 선정Kaggle에 있는 다양한 데이터들 중에 선정을 했다.둘러보던 중 OTT 서비스에 대한 데이터가 있길래 흥미로워서 이거로 선택했다.OTT 서비스 제공자(넷플릭스, Hulu, Prime Video, Dismey+)들을 비교해논 데이터이다.데이터 항목은 크게 영화에 대한 정보들과 어떤 OTT 플랫폼에서 제공되고 있는지가 있다.총 17가지의 속성이 있..." }, { "title": "[알고리즘] 프로그래머스 - 행렬의 곱셈", "url": "/posts/Algorithm82/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2021-01-06 20:00:00 +0900", "snippet": "문제행렬의 곱셈접근행렬 곱은 (a x b) x (b x c) 크기의 행렬을 곱했을 때(a x c) 행렬이 나오며 내부적인 연산은 각 요소마다 b번의 곱을 해야 한다.3중 for문으로 해결했다.첫 번째 포문은 a를 의미한다.두 번째 포문은 c를 의미한다.세 번째 포문은 b를 의미한다.코드 파이썬 코드def solution(arr1, arr2): answer = [] for i in range(len(arr1)): tmp = [] for j in range(len(arr2[0])): ..." }, { "title": "[알고리즘] 프로그래머스 - 피보나치 수", "url": "/posts/Algorithm81/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2021-01-06 20:00:00 +0900", "snippet": "문제피보나치 수접근DP를 이용하여 n까지 연산하면 된다.1234567 로 나눈 수를 반환하기 때문에 오버플로우는 걱정하지 않아도 될 것 같다.코드 파이썬 코드def solution(n): dp = [0]*(n+2) dp[0] = 0 dp[1] = 1 if n == 1: return 1 for i in range(2, n+1): dp[i] = (dp[i-1] + dp[i-2]) % 1234567 return dp[n] C++ 코드#include &amp;lt;vecto..." }, { "title": "[프로그래머스 인공지능스쿨] Week5-1 Machine Learning 기초 : 결정이론", "url": "/posts/Day22/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-06 00:00:00 +0900", "snippet": "강의결정 이론(Decision Theory)\\(\\rhd\\) 결정이론이란?새로운 값 x가 주어졌을 때 확률모델 p(x,t)에 기반해 최적의 결정을 내리는 것 추론단계: 결합확률분포 \\(p(x, C_{k})\\)를 구하는 것 결정단계: 추론단계를 통해 어떻게 최적의 결정을 내릴 것인지 직관적으로 볼 때 $$p(C_{k} x)$$를 최대화시키는 k를 구하는 것이 좋은 결정 \\(\\rhd\\) 확률 변수(Random Variable)확률 변수 X는 표본 집합 S의 원소 e를 실수 값 \\(X(e) =..." }, { "title": "[알고리즘] 프로그래머스 - 점프와 순간 이동", "url": "/posts/Algorithm80/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2021-01-04 20:00:00 +0900", "snippet": "문제점프와 순간 이동접근순간이동(x2)는 건전지 소모가 없다.목표는 건전지 소모를 최소화하는 것이므로, 가능한 경우에는 항상 순간이동을 이용하는 것이 최선의 결과를 가져올 것이다.목표 지점인 n부터 시작해서 0으로 거꾸로 이동하며 순간이동이 불가능한 경우(홀수인 경우)에만 점프를 한다.코드 파이썬 코드def solution(n): ans = 0 while n != 0: if n % 2 == 0: n //= 2 else: n -= 1 ..." }, { "title": "[프로그래머스 인공지능스쿨] Week5-1 Machine Learning 기초 : 확률이론", "url": "/posts/Day21/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2021-01-04 00:00:00 +0900", "snippet": "강의Machine Learning 기초\\(\\rhd\\) Machine Learning 이란?경험을 통해 자동으로 개선하는 컴퓨터 알고리즘으로,학습 데이터를 이용해 목표값을 예측한다.\\(\\rhd\\) Machine Learning 기초 개념학습 단계: 함수 y(x)를 학습 데이터에 기반해 결정하는 단계시험 셋: 모델을 평가하기 위해서 사용하는 새로운 데이터일반화: 모델에서 학습에 사용된 데이터가 아닌 새로운 데이터에 대해 올바른 예측을 수행하는 역량지도학습: target이 주어진 경우 분류(classification) 회귀(r..." }, { "title": "[프로그래머스 인공지능스쿨] Week4-4 Django (2)", "url": "/posts/Day20/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-24 18:00:00 +0900", "snippet": "강의Djangomodel 생성하기django에서는 model을 이용하여 DB를 관리한다.model은 app의 models.py에서 class 형식으로 관리할 수 있다.class Coffee(models.Model): def __str__(self): return self.name name = models.CharField(default=&quot;&quot;, max_length=30) price = models.IntegerField(default=0) is_ice = models.Boole..." }, { "title": "[프로그래머스 인공지능스쿨] Week4-3 Django (1)", "url": "/posts/Day19/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-23 18:00:00 +0900", "snippet": "강의DjangoPython 기반 웹 프레임워크Flask에 비해 프로젝트의 크기가 크다.설치는 cmd에서 pip install django 명령을 통해 설치한다.프로젝트를 시작하기 위해서는 django-admin startproject pro_name 명령을 통해 새로운 프로젝트를 생성한다.생성된 프로젝트에서 서버를 실행하는 방법은 python manage.py runserver 명령어를 통해서 실행하며,127.0.0.1:8000/admin 에 접속하여 확인할 수 있다.admin 생성하기python manage.py migrat..." }, { "title": "[프로그래머스 인공지능스쿨] Week4-1 Flask", "url": "/posts/Day17/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-21 18:00:00 +0900", "snippet": "강의Flask파이썬 기반의 웹 프레임워크 파이썬 가상환경 설정하기cmd 에서 virtualenv env_name 를 입력해주면 현재 폴더에 env_name이란 가상환경을 설치할 수 있다.실행은 .\\env_name\\scripts\\activate 명령으로 실행할 수 있다.해제는 deactivate 로 가상환경을 해제한다. 가상환경에서 패키지 설치하기가상환경을 실행한 후 pip을 통해 install한다.현재 가상환경내에 설치되어 있는 패키지 목록은 pip freeze 명령어를 통해 확인할 수 있다. 웹 페이지 생성하기app.p..." }, { "title": "[알고리즘] 프로그래머스 - 위장", "url": "/posts/Algorithm79/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-18 20:00:00 +0900", "snippet": "문제위장접근의상의 종류들의 조합을 구해야한다.딕셔너리를 사용하여 종류별로 카운트를 해주고, 조합을 구한다.알몸으로 다닐 수는 없으니, 전체 조합에서 공집합을 빼준다.코드 파이썬 코드def solution(clothes): answer = 1 dic = {} for clothe in clothes: dic[clothe[1]] = dic.get(clothe[1], 0) + 1 for value in dic.values(): answer *= (value+1) answer -= ..." }, { "title": "[알고리즘] 프로그래머스 - 폰켓몬", "url": "/posts/Algorithm78/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-18 20:00:00 +0900", "snippet": "문제폰켓몬접근문제가 복잡해보이지만, 중복없이 최대한 많은 수를 선택하는 문제이다.코드 파이썬 코드def solution(nums): n = len(nums) // 2 num = set(nums) answer = min(n, len(num)) return answer C++ 코드#include &amp;lt;vector&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int solution(ve..." }, { "title": "[알고리즘] 프로그래머스 - 예상 대진표", "url": "/posts/Algorithm77/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-18 20:00:00 +0900", "snippet": "문제예상 대진표접근A, B를 2로 나눈 몫이 같아질 때 만나게 된다.인덱스 조정을 위해 시작을 0부터로 해야 한다.코드 파이썬 코드def solution(n,a,b): answer = 0 a -= 1 b -= 1 while a!=b: a//=2 b//=2 answer+=1 return answer C++ 코드#include &amp;lt;iostream&amp;gt;using namespace std;int solution(int n, int a, int b)..." }, { "title": "[알고리즘] 프로그래머스 - 숫자의 표현", "url": "/posts/Algorithm76/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-17 20:00:00 +0900", "snippet": "문제숫자의 표현접근start = 1와 end = 1를 이용한다. end부터 숫자를 더해나가며 n보다 같거나 커지게 만든다. n과 같다면 경우의 수를 한개 더한다. start부터 숫자를 하나씩 빼며 n보다 같거나 작아지게 만든다. n과 같다면 경우의 수를 한개 더한다. 다시 1로 돌아간다.코드 파이썬 코드def solution(n): answer = 0 start = 1 end = 1 now = 0 while start &amp;lt; n: while now &amp;lt;= n..." }, { "title": "[알고리즘] 프로그래머스 - 구명보트", "url": "/posts/Algorithm75/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-17 20:00:00 +0900", "snippet": "문제구명보트접근이 문제에서 가장 중요한 것은 최대 탑승인원이 2명이라는 것이다.가장 무거운 사람을 태우고, 남은 한자리에 태울 수 있는 사람이 있다면 누굴 태우든 상관이 없어진다.최대 무게에 딱 맞출 필요가 없다는 것이다.2명을 태우는 것에만 집중하면 된다.역순으로 정렬하고 가장 무거운 사람을 태우고, 가장 가벼운 사람을 태울 수 있다면 함께 태우고, 불가능하면 혼자타면 된다.예를 들어 [50, 40, 20, 10] 이 있다면, 50과 함께 태울 사람을 고르는데 시간을 쓰지말고, 가장 뒤에 있는 10만 검사해준다.코드 파이썬..." }, { "title": "[알고리즘] 프로그래머스 - H-Index", "url": "/posts/Algorithm74/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-17 20:00:00 +0900", "snippet": "문제H-Index접근처음에 문제를 잘못 이해해서 헤맸다.citations 배열을 역순으로 정렬해준다.citations[i]와 i 중 작은 것을 선택하자.이것은 무조건 h를 만족한다. h의 최대값을 찾으면 된다.코드 파이썬 코드def solution(citations): citations.sort(reverse=True) answer = 0 for cnt, citation in enumerate(citations): now = min(citation, cnt+1) if answer &..." }, { "title": "[프로그래머스 인공지능스쿨] Week3-1 Python - EDA", "url": "/posts/Day16/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-17 18:00:00 +0900", "snippet": "강의EDA Process 데이터 분석의 목적 및 변수(파라미터) 확인하기 데이터 전체적으로 살펴보기 데이터의 개별 속성 파악하기타이타닉 데이터 분석하기import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns%matplotlib inlinetitanic_df = pd.read_csv(&quot;./train.csv&quot;) 데이터 살펴보기Correlation is NOT Causation상관관계가 유의미하다고해서, ..." }, { "title": "[프로그래머스 인공지능스쿨] Week3-1 Python - Matplotlib", "url": "/posts/Day15/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-16 15:00:00 +0900", "snippet": "강의Matplotlibimport matplotlib.pyplot as plt%matplotlib inline꺾은선 그래프(plot)x = np.arange(-10,10,0.01)plt.xlabel(&quot;x value&quot;)plt.ylabel(&quot;f(x) value&quot;)plt.axis([-5,5,0,25]) # [x_min, x_max, y_min, y_max]plt.xticks([i for i in range(-5,6,1)])plt.yticks([i for i in range(0,27,3)])plt...." }, { "title": "[알고리즘] 프로그래머스 - 124나라의 숫자", "url": "/posts/Algorithm73/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-15 22:00:00 +0900", "snippet": "문제124나라의 숫자접근3진법에서 숫자 표기를 1,2,4를 이용하여 하면 된다.주의할 점은 나머지가 0인 경우에는 몫을 하나 빼줘야 규칙에 맞아떨어진다.내 생각에는 이 숫자체계는 0이 존재하지 않기 때문인거 같다. 코드 파이썬 코드def solution(n): answer = &#39;&#39; dic = [&#39;4&#39;, &#39;1&#39;, &#39;2&#39;] while n&amp;gt;0: num = n%3 answer = dic[num] + answer ..." }, { "title": "[알고리즘] 프로그래머스 - 다리를 지나는 트럭", "url": "/posts/Algorithm72/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-15 22:00:00 +0900", "snippet": "문제다리를 지나는 트럭접근문제 예시에서 보여준 것처럼 생각했다.다리 위에 있는 트럭들을 나타내는 큐를 하나 만들어서 1초 단위로 움직여주며 생각했다.매초마다 다리위에 트럭들은 한칸씩 전진하고, 무게에 여유가 있다면 새로운 트럭이 올라오고, 안된다면 빈 공간을 올리는 식으로 하였다.예를 들어, 다리 길이가 5이고, 최대 허용무게가 10이면 [0, 0, 0, 0, 0]인 큐를 만들고, 트럭을 하나씩 append 해준다.진행방향은 오른쪽에서 왼쪽이다. [0, 0, 0, 0, 7][0, 0, 0, 7, 3][0, 0, 7, 3, ..." }, { "title": "[프로그래밍 언어] 파이썬 - 모듈", "url": "/posts/languagePython2/", "categories": "프로그래밍 언어, Python", "tags": "Programming, Language, Python", "date": "2020-12-15 20:00:00 +0900", "snippet": "Contents queue Queue Stack Priority Queue queue파이썬은 queue 모듈을 통해 큐(Queue), 스택(Stack), 우선순위큐(PriorityQueue)를 제공한다.import queueQueue 생성q = queue.Queue() 삽입q.put(item) 삭제파이썬에서는 별도의 top() 함수를 제공하지 않는다.get()을 통해 원소를 삭제하고 삭제한 원소를 반환한다.item = q.get() 크기size = q.qsize()Stack ..." }, { "title": "[프로그래머스 인공지능스쿨] Week3-1 Python - pandas", "url": "/posts/Day14/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-15 18:00:00 +0900", "snippet": "강의pandasimport pandas as pdSeries1차원 데이터 다루기s = pd.Series([1,4,9,16,26])t = pd.Series({&#39;one&#39;:1, &#39;two&#39;:2, &#39;three&#39;:3})s[1]# 4s[[3,1,4]]# 16, 4, 26s[s &amp;gt; s.median()]# 16 26t[&#39;one&#39;]# 1t[&#39;four&#39;] = 4# t = {&#39;one&#39;:1, &#39;two&#39;:2, &#39;three&#39;:3..." }, { "title": "데이터베이스 정리 6 - Oracle SQL Query", "url": "/posts/DBCourse6/", "categories": "IT, Database", "tags": "IT, DB, Database", "date": "2020-12-14 21:20:00 +0900", "snippet": "Contents SQL Query SELECT ORDER BY WHERE JOIN Having 서브 쿼리 SQL QuerySELECTSELECT 컬럼1, 컬럼2 FROM 테이블;SELECT 컬럼1 (as) 별명1, 컬럼2 (as) 별명2 FROM 테이블;SELECT * FROM 테이블;DESC 테이블;테이블로 부터 지정한 컬럼을 검색한다. 컬럼컬럼은 ,를 사용해 연결할 수 있다.‘*‘을 이용하여 테이블내의 모든 컬럼을 검색할 수 있다.별명을 이용하..." }, { "title": "[프로그래머스 인공지능스쿨] Week3-1 Python - numpy", "url": "/posts/Day13/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-14 20:00:00 +0900", "snippet": "강의numpyimport numpy as np행렬 만들기arr = np.array([[1,2,3],[4,5,6],[7,8,9]])요소 참조, 슬라이싱arr[1, 2]# 6arr[1: , :1]# 기존 리스트 슬라이싱과 동일영벡터, 일벡터np.zeros((3,3))np.ones((3,1))#인자는 튜플 형식으로대각행렬, 항등행렬np.diag((2,4))# [[2,0],[0,4]]np.eye(2)# [[1,0],[0,1]]# 인자로 데이터 타입 지정 가능, default는 floatnp.eye(2, dtype = int)행렬 곱m..." }, { "title": "[알고리즘] 프로그래머스 - 키패드 누르기", "url": "/posts/Algorithm71/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-13 16:50:00 +0900", "snippet": "문제키패드 누르기접근3으로 나눈 몫과 나머지의 조합으로 생각하면 쉽다. 이를 위해서 *, 0, #은 각각 10, 11 12로 생각하고 푼다.우선 키패드가 어떤 줄에 있는지는 3으로 나눈 나머지를 이용한다.나머지가 1이면 왼쪽, 0이면 오른쪽, 2이면 가운데이다.가운데 줄인 경우 거리를 계산해야 한다.거리의 경우, 두 숫자의 차이의 몫과 나머지를 더하면 된다.다음과 같이 구할 수 있다.손가락이 있는 번호 \\(=hand\\)눌러야할 번호 \\(=key\\)거리 \\(=d\\)\\[t = \\mid hand - key \\midd = t % 3 ..." }, { "title": "[알고리즘] 프로그래머스 - [1차] 비밀지도", "url": "/posts/Algorithm70/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-13 16:50:00 +0900", "snippet": "문제[1차]비밀지도접근비트 연산을 이용하는 문제이다.두 배열을 or 연산하면 정답이 나온다.이를 2진수 기준으로 공백과 벽을 대입하면 된다.코드 파이썬 코드def solution(n, arr1, arr2): answer = [] for i in range(n): a = arr1[i] | arr2[i] s = &#39;&#39; for j in range(n): if a%2 == 0: s = &quot; &quot;+s ..." }, { "title": "[알고리즘] 프로그래머스 - 이상한 문자 만들기", "url": "/posts/Algorithm69/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-13 16:50:00 +0900", "snippet": "문제이상한 문자 만들기접근코드 파이썬 코드def solution(s): answer = &#39;&#39; index = 0 for item in s: if item == &#39; &#39;: index = 0 answer += item continue if index % 2 == 0: answer += item.upper() else: answer += item.lower..." }, { "title": "[알고리즘] 프로그래머스 - 최대공약수와 최소공배수", "url": "/posts/Algorithm68/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-13 16:50:00 +0900", "snippet": "문제최대공약수와 최소공배수접근그냥 숫자하나하나 해봤다.코드 파이썬 코드def solution(n, m): answer = [] if n&amp;gt;m: min_v, max_v = m, n else: min_v, max_v = n, m for i in range(min_v, 0, -1): if n%i == 0 and m%i == 0: answer.append(i) break for i in range(max_v, n*m+1..." }, { "title": "[알고리즘] 프로그래머스 - 시저 암호", "url": "/posts/Algorithm67/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-13 16:50:00 +0900", "snippet": "문제시저 암호접근아스키 코드로 왔다갔다했다.개인적으로 아스키 코드는 C++이 더 편한거 같기도 하다.코드 파이썬 코드def solution(s, n): answer = &#39;&#39; for item in s: if item.isupper(): answer += chr((ord(item) - ord(&#39;A&#39;) + n)%26 + ord(&#39;A&#39;)) elif item.islower(): answer += chr((ord(ite..." }, { "title": "[알고리즘] 프로그래머스 - 문자열 다루기 기본", "url": "/posts/Algorithm66/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-13 16:50:00 +0900", "snippet": "문제문자열 다루기 기본접근파이썬 isdecimal() 은 해당 문자열의 모든 자리가 정수일때 true를 반환한다.코드 파이썬 코드def solution(s): if len(s) != 4 and len(s) != 6: return False if not s.isdecimal(): return False return True C++ 코드#include &amp;lt;string&amp;gt;using namespace std;bool solution(string s) { if(s...." }, { "title": "[알고리즘] 프로그래머스 - 문자열 내림차순으로 배치하기", "url": "/posts/Algorithm65/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-13 16:50:00 +0900", "snippet": "문제문자열 내림차순으로 배치하기접근sorted 함수를 이용하면 문자열도 정렬이 가능하다.리스트형으로 반환되는 것같아서 join을 해주었다.코드 파이썬 코드def solution(s): s = &#39;&#39;.join(sorted(s, reverse = True)); return s C++ 코드#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;string solution(string s) { sort(s...." }, { "title": "[알고리즘] 프로그래머스 - 문자열 내 마음대로 정렬하기", "url": "/posts/Algorithm64/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-13 16:50:00 +0900", "snippet": "문제문자열 내 마음대로 정렬하기접근람다는 쓰면 쓸수록 정말 편리하다.C++은 직접 비교함수를 만들어주었다.n을 인자로 주고 싶었는데 방법이 없어서 그냥 전역변수로 넘겼다.코드 파이썬 코드def solution(strings, n): strings.sort() return sorted(strings, key = lambda x : x[n]) C++ 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp..." }, { "title": "[프로그래밍 언어] C++ - STL 정리", "url": "/posts/languageCpp1/", "categories": "프로그래밍 언어, Cpp", "tags": "Programming, Language, Cpp", "date": "2020-12-12 23:00:00 +0900", "snippet": "Contents STL(Standard Template Library) Vector Stack Queue Priority Queue Deque Set, MultiSet Map, MultiMap STL(Standard Template Library)Vector배열과 거의 비슷하지만, 메모리를 잡아주지 않아도 된다.배열 동적할당의 상위버전이랄까 header#include &amp;lt;vector&amp;gt; 생성vector&amp;lt;int&..." }, { "title": "[알고리즘] 프로그래머스 - 직사각형 별찍기", "url": "/posts/Algorithm63/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제직사각형 별찍기접근주어지는 n,m 만큼 별을 출력하면 된다.코드 파이썬 코드a, b = map(int, input().strip().split(&#39; &#39;))for i in range(b): s = &quot;*&quot;*a print(s) C++ 코드#include &amp;lt;iostream&amp;gt;using namespace std;int main(void) { int a; int b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; f..." }, { "title": "[알고리즘] 프로그래머스 - 제일 작은 수 제거하기", "url": "/posts/Algorithm62/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제제일 작은 수 제거하기접근최소값을 찾고 해당 값을 배열에서 제거하면 된다.코드 파이썬 코드def solution(arr): minIdx = 0 for i in range(1,len(arr)): if arr[minIdx] &amp;gt; arr[i]: minIdx = i del arr[minIdx] return arr C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; so..." }, { "title": "[알고리즘] 프로그래머스 - 실패율", "url": "/posts/Algorithm61/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제실패율접근 각 스테이지에 도전 중인 사람 수 세기 각 스테이지별 실패율 구하기 실패율로 정렬하여 정답 반환1의 경우 해시 테이블을 이용하여 해결하였다.2의 경우에 실패율은 (해당 스테이지에 도전중인 사람) / (전체 인원 - 해당 스테이지 이전에 도전중인 사람) 이다.1스테이지부터 시작해서 실패율을 구해주며 전체 인원에서 해당 인원을 빼는 식으로 하면 O(N)에 해결가능하다.마지막 3번의 경우는 실패율로 정렬을 하지만, 반환값은 스테이지이기 때문에, 실패율과 스테이지를 묶어서 정렬해야 한다.나는 우선순위 큐를 이용하여..." }, { "title": "[알고리즘] 프로그래머스 - [1차] 다트 게임", "url": "/posts/Algorithm60/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제[1차]다트게임접근점수 중에 10점도 있기 때문에 이러한 경우를 한번 전처리하면서 걸러주었다.10점을 묶어서 저장하기 위해 리스트로 바꿔서 저장해두고, 해당 리스트를 이용해 점수를 계산했다.전처리하는 부분에서 i+1이 범위를 넘어갈까봐 체크하는 부분을 두었는데, 생각해보니 점수가 가장 마지막에 오는 경우는 없다. (점수와 보너스는 항상 있기 때문)옵션 중 이전 점수와 현재 점수를 두 배하는 부분을 쉽게 처리하기 위해 score 배열은 인덱스를 1부터 시작하도록 생각했다.C++의 경우 숫자인지 판별하기가 귀찮아서 그냥 모든 ..." }, { "title": "[알고리즘] 프로그래머스 - 정수 내림차순으로 배치하기", "url": "/posts/Algorithm59/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제정수 내림차순으로 배치하기접근각 자리 숫자에 대해 해시 테이블을 만들어 개수를 카운팅하면 쉽게 해결 가능하다.코드 파이썬 코드def solution(n): cnt = [0] * 10 answer = 0 while n&amp;gt;0: cnt[n%10]+=1 n//=10 for i in range(9, -1, -1): while cnt[i] &amp;gt; 0: cnt[i] -= 1 answer = answer*10 + i ..." }, { "title": "[알고리즘] 프로그래머스 - 핸드폰 번호 가리기", "url": "/posts/Algorithm58/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제핸드폰 번호 가리기접근전체 길이 - 4만큼 별이 있어야 하고,그 이후 자리를 이어 붙이면 된다.코드 파이썬 코드def solution(phone_number): starCnt = len(phone_number) - 4 answer = &#39;*&#39; * starCnt answer += str(phone_number[starCnt:]) return answer C++ 코드#include &amp;lt;string&amp;gt;using namespace std;string solution(str..." }, { "title": "[알고리즘] 프로그래머스 - 약수의 합", "url": "/posts/Algorithm57/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제약수의 합접근n까지 돌며 나누어 떨어지는 수들을 더하면 된다.n의 범위에 0도 포함되어 있으므로 주의해야 한다. for문의 범위를 1부터 시작해주면 신경쓰지 않아도 된다.코드 파이썬 코드def solution(n): answer = 0 for i in range(1,n+1): if n%i == 0: answer+=i return answer C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;int solution(int ..." }, { "title": "[알고리즘] 프로그래머스 - 자연수 뒤집어 배열로 만들기", "url": "/posts/Algorithm56/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제자연수 뒤집어 배열로 만들기접근10으로 나누며 나머지를 한자리씩 담아주면 된다.코드 파이썬 코드def solution(n): answer = [] while n&amp;gt;0: answer.append(n%10) n //= 10 return answer C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(long long n) { vector&amp;lt;int..." }, { "title": "[알고리즘] 프로그래머스 - 정수 제곱근 판별", "url": "/posts/Algorithm55/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제정수 제곱근 판별접근1부터 n까지 올라가며 하나씩 제곱해서 같은지 비교할 수 있다.좀 더 빠른 방법은 1부터 n까지를 이분 탐색하면 된다.하지만 math에 sqrt 라는 좋은 함수가 있으니 이를 이용하면 간단하게 해결할 수 있다.코드 파이썬 코드import mathdef solution(n): answer = math.sqrt(n) if answer % 1 == 0: return (answer+1)*(answer+1) else: return -1 C++ 코드#include &am..." }, { "title": "[알고리즘] 프로그래머스 - x만큼 간격이 있는 n개의 숫자", "url": "/posts/Algorithm54/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제x만큼 간격이 있는 n개의 숫자접근코드 파이썬 코드def solution(x, n): answer = [] num = x for _ in range(n): answer.append(num) num += x return answer C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;long long&amp;gt; solution(int x, int n) { vector&amp;lt;long lo..." }, { "title": "[알고리즘] 프로그래머스 - 행렬의 덧셈", "url": "/posts/Algorithm53/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-12 22:50:00 +0900", "snippet": "문제행렬의 덧셈접근코드 C++ 코드#include &amp;lt;string&amp;gt;using namespace std;string solution(int num) { string answer = &quot;&quot;; if(num%2 == 0){ answer = &quot;Even&quot;; } else{ answer = &quot;Odd&quot;; } return answer;} 파이썬 코드def solution(num): if num % 2 ==..." }, { "title": "[알고리즘] 프로그래머스 - 짝수와 홀수", "url": "/posts/Algorithm52/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:50:00 +0900", "snippet": "문제짝수와 홀수접근코드 C++ 코드#include &amp;lt;string&amp;gt;using namespace std;string solution(int num) { string answer = &quot;&quot;; if(num%2 == 0){ answer = &quot;Even&quot;; } else{ answer = &quot;Odd&quot;; } return answer;} 파이썬 코드def solution(num): if num % 2 ==..." }, { "title": "[알고리즘] 프로그래머스 - 하샤드 수", "url": "/posts/Algorithm51/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:45:00 +0900", "snippet": "문제하샤드 수접근코드 C++ 코드using namespace std;bool solution(int x) { bool answer = true; int num = x, n = 0; while(num &amp;gt; 0){ n += num%10; num /= 10; } if(x%n == 0){ answer = true; } else{ answer = false; } return answer;} 파이썬 코드def solution(..." }, { "title": "[알고리즘] 프로그래머스 - 콜라츠 추측", "url": "/posts/Algorithm50/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:40:00 +0900", "snippet": "문제콜라츠 추측접근코드 C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;int solution(int _num) { long long num = _num; int answer = 0; while (1){ if(num == 1){ break; } answer++; if(num % 2 == 0){ num /= 2; } else{ ..." }, { "title": "[알고리즘] 프로그래머스 - 자릿수 더하기", "url": "/posts/Algorithm49/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:35:00 +0900", "snippet": "문제자릿수 더하기접근코드 C++ 코드using namespace std;int solution(int n){ int answer = 0; while(n&amp;gt;0){ answer += n%10; n /= 10; } return answer;} 파이썬 코드def solution(n): answer = 0 while n &amp;gt; 0: answer += n%10 n //= 10 return answer" }, { "title": "[알고리즘] 프로그래머스 - 평균 구하기", "url": "/posts/Algorithm48/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:30:00 +0900", "snippet": "문제평균 구하기접근코드 C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;double solution(vector&amp;lt;int&amp;gt; arr) { double answer = 0; int n = arr.size(); for (int i=0;i&amp;lt;n;i++){ answer += arr[i]; } answer /= n; return answer;} 파이썬 코드def solution(arr): answe..." }, { "title": "[알고리즘] 프로그래머스 - 내적", "url": "/posts/Algorithm47/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:25:00 +0900", "snippet": "문제내적접근코드 C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; b) { int answer = 0; for(int i = 0; i &amp;lt; a.size(); i++){ answer += a[i]*b[i]; } return answer;} 파이썬 코드def solution(a, b): answer = 0 ..." }, { "title": "[알고리즘] 프로그래머스 - 문자열을 정수로 바꾸기", "url": "/posts/Algorithm46/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:20:00 +0900", "snippet": "문제문자열을 정수로 바꾸기접근가장 앞이 부호로 시작하는지 숫자로 시작하는지 판별하고, 부호가 -이면 음수로 바꾼다.코드 C++ 코드#include &amp;lt;string&amp;gt;using namespace std;int solution(string s) { int answer = 0; if(s[0] == &#39;+&#39; || s[0] == &#39;-&#39;){ answer = stoi(s.substr(1)); if(s[0] == &#39;-&#39;) ..." }, { "title": "[알고리즘] 프로그래머스 - 서울에서 김서방 찾기", "url": "/posts/Algorithm45/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:15:00 +0900", "snippet": "문제서울에서 김서방 찾기접근배열 순회 문제코드 C++ 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(vector&amp;lt;string&amp;gt; seoul) { string answer = &quot;김서방은 &quot;; for(int i = 0; i&amp;lt;seoul.size(); i++){ if(seoul[i] == &quot;Kim&quot;){ ..." }, { "title": "[알고리즘] 프로그래머스 - K번째수", "url": "/posts/Algorithm44/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:10:00 +0900", "snippet": "문제K번째수접근해당 구간을 복사하여 정렬한다.구간을 복사하는 것은 슬라이싱을 통해 간단하게 해결 가능하다.다음 command는 원본 배열을 사용해야 한다.코드 파이썬 코드def solution(array, commands): answer = [] for s, e, k in commands: arr = array[s-1:e] arr.sort() answer.append(arr[k-1]) return answer C++ 코드#include &amp;lt;vector&amp;..." }, { "title": "[알고리즘] 프로그래머스 - 가운데 글자 가져오기", "url": "/posts/Algorithm43/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-11 22:05:00 +0900", "snippet": "문제가운데 글자 가져오기접근문자열의 길이가 짝수인 경우와 홀수인 경우를 나누어서, 다른 인덱스를 반환 코드 C++ 코드#include &amp;lt;string&amp;gt;using namespace std;string solution(string s) { string answer = &quot;&quot;; int l = s.size() / 2; if(s.size() % 2){ answer = s[l]; } else{ answer = s.substr(l-1, 2); ..." }, { "title": "[프로그래머스 인공지능스쿨] Week2-5 인공지능 수학 : 추정, 검정, 엔트로피", "url": "/posts/Day12/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-11 22:00:00 +0900", "snippet": "강의자기정보(self-information) : i(A)A : 사건\\[i(A) = log_{b}(\\frac{1}{P(A)}) = -log_{b}P(A)\\]\\[i(AB) = log_{b}(\\frac{1}{P(A)P(B)}) = log_{b}(\\frac{1}{P(A)}) + log_{b}(\\frac{1}{P(B)}) = i(A) + i(B)\\]엔트로피(entropy)자기정보의 평균\\[H(X) = \\sum_{j}P(A_{j})i(A_{j}) = -\\sum_{j}P(A_{j})log_{2}P(A_{j})\\]\\[0 \\le H(X) \\l..." }, { "title": "[프로그래머스 인공지능스쿨] Week2-4 인공지능 수학 : 확률과 확률분포", "url": "/posts/Day11/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-10 12:00:00 +0900", "snippet": "강의확률 똑같은 실험을 무수히 많이 반복할 때 어떤 일이 일어나는 비율A라는 어떤 사건이 일어날 확률 : P(A)확률은 0에서 1사이의 값을 가짐 조합(combination)어떤 집합에서 순서에 상관없이 뽑은 원소의 집합n 개 중 r개를 뽑는 조합의 수\\[_{n}C_{r} =\\left(\\begin{array}{r}n\\\\r\\end{array}\\right)= \\frac{n!}{r!(n-r)!}\\] 덧셈 법칙사건 A나 B가 일어날 확률\\[P(A \\cup B) = \\frac{\\mid A \\cup B \\mid}{\\mid S\\mid..." }, { "title": "[알고리즘] 프로그래머스 - 수박수박수박수박수박수?", "url": "/posts/Algorithm42/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-09 22:00:00 +0900", "snippet": "문제수박수박수박수박수박수?접근두 개씩 묶어서 하고 마지막에 남는지 안남는지만 체크코드 C++ 코드#include &amp;lt;string&amp;gt;using namespace std;string solution(int n) { string answer = &quot;&quot;; for(int i = 0; i&amp;lt;n/2;i++) answer += &quot;수박&quot;; if (n%2 == 1) answer += &quot;수&quot;; re..." }, { "title": "[알고리즘] 프로그래머스 - 3진법 뒤집기", "url": "/posts/Algorithm41/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-09 22:00:00 +0900", "snippet": "문제3진법 뒤집기접근 10진법을 3진법으로 바꾸기 3진법을 뒤집기 3진법을 10진법으로 바꾸기이 과정에서 1,2번은 한번에 해결할 수 있다.3진법으로 바꾸는 과정에서 뒤집어서 저장하면 된다.C++ 같은 경우 int형으로 할 경우 오버플로우가 발생할 수 있다.코드 C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;int solution(int n) { long long answer = 0, base3 = 0; int t = 1; while(n&amp;gt..." }, { "title": "[알고리즘] 프로그래머스 - 소수 찾기", "url": "/posts/Algorithm40/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-09 22:00:00 +0900", "snippet": "문제소수 찾기접근n까지의 모든 소수의 개수를 세는 문제이다.에라토스테네스의 체를 이용하면 쉽게 소수를 찾을 수 있다.코드 C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;int arr[1000001];int solution(int n) { int answer = 0; for(int i = 2; i&amp;lt;=n;i++){ if(arr[i] != 0) continue; answer++; for(int j..." }, { "title": "[알고리즘] 프로그래머스 - 문자열 내 p와 y의 개수", "url": "/posts/Algorithm39/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-09 22:00:00 +0900", "snippet": "문제문자열 내 p와 y의 개수접근그냥 p, y 개수를 센다. 코드 C++ 코드#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;bool solution(string s){ int pCnt = 0, yCnt = 0; for(int i = 0; i&amp;lt; s.size(); i++){ if(s[i] == &#39;p&#39; || s[i] == &#39;P&#39;) pCnt++..." }, { "title": "[알고리즘] 프로그래머스 - 두 정수 사이의 합", "url": "/posts/Algorithm38/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-09 22:00:00 +0900", "snippet": "문제두 정수 사이의 합접근대소관계가 정해져 있지 않으므로 이부분만 주의하면 쉽게 해결가능하다. 코드 C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;long long solution(int a, int b) { long long answer = 0; if (a&amp;gt;b){ int tmp = a; a = b; b = tmp; } for(int i = a; i &amp;lt;= b; i++){ a..." }, { "title": "[알고리즘] 프로그래머스 - 같은 숫자는 싫어", "url": "/posts/Algorithm37/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-09 22:00:00 +0900", "snippet": "문제같은 숫자는 싫어접근배열을 순회하며 answer의 마지막 원소와 비교하며 넣을지 버릴지 정해주면 된다. 코드 C++ 코드#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; arr){ vector&amp;lt;int&amp;gt; answer; int idx; for(int i = 0; i&amp;lt..." }, { "title": "[알고리즘] 프로그래머스 - 나누어 떨어지는 숫자 배열", "url": "/posts/Algorithm36/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-09 22:00:00 +0900", "snippet": "문제나누어 떨어지는 숫자 배열접근arr를 순회하며 나머지가 0인 수들만 따로 저장해두고 이를 정렬하면 된다.코드 C++ 코드#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; arr, int divisor) { vector&amp;lt;int&amp;gt; answer; for(int i = 0; i&amp;..." }, { "title": "[프로그래머스 인공지능스쿨] Week2-3 인공지능 수학 : 자료의 정리", "url": "/posts/Day10/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-09 15:00:00 +0900", "snippet": "강의벡터의 내적두 벡터 \\(u = (u_{1}, u_{2}, ... , u_{n}), v = (v_{1}, v_{2}, ... , v_{n})\\)의 좌표값을 통해 다음과 같이 계산된다.\\[uv = u_{1}v_{1} + u_{2}v_{2} + ... + u_{n}v_{n}\\]두 벡터간의 내적이 \\(uv = 0\\)이면, 두 벡터는 직교이다.투영(Projection)두 벡터 u, a가 있을 때, 벡터 u를 a위에 투영한 벡터를 \\(proj_{a}u\\)라고 하며, 다음과 같이 구한다.\\[proj_{a}u = (길이)(방향) = (u..." }, { "title": "[알고리즘] 프로그래머스 - 모의고사", "url": "/posts/Algorithm35/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-08 23:00:00 +0900", "snippet": "문제모의고사접근1,2,3번 수포자의 반복되는 패턴을 미리 저장해둔다.1번 = {1,2,3,4,5}2번 = {2,1,2,3,2,4,2,5}3번 = {3,3,1,1,2,2,4,4,5,5}그 후 answers의 원소들과 각 수포자의 답과 비교하여 맞은 개수를 카운팅해주면 된다.코드 C++ 코드#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; answers) { vector&am..." }, { "title": "[프로그래머스 인공지능스쿨] Week2-2 인공지능 수학 : 미적분", "url": "/posts/Day9/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-08 22:00:00 +0900", "snippet": "강의LU분해L : lower triangular matrix(하삼각행렬)U : upper triangular matrix(상삼각행렬)\\[A = L U\\]\\[\\left[\\begin{array}{rrr}*&amp;amp;*&amp;amp;*\\\\*&amp;amp;*&amp;amp;*\\\\*&amp;amp;*&amp;amp;*\\end{array}\\right]=\\left[\\begin{array}{rrr}*&amp;amp;0&amp;amp;0\\\\*&amp;amp;*&amp;amp;0\\\\*&amp;amp;*&amp;amp;*\\end{arra..." }, { "title": "[알고리즘] 프로그래머스 - 두 개 뽑아서 더하기", "url": "/posts/Algorithm34/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-07 23:30:00 +0900", "snippet": "문제두 개 뽑아서 더하기접근배열의 원소 중 두개를 뽑아 더한 결과의 집합을 구하는 문제이다.완전탐색을 해주면 되는데, 중복되는 결과를 어떻게 제거하는지가 관건이다.파이썬의 경우 set() 을 이용하여 쉽게 해결이 가능하다.C++의 경우는 STL을 사용하면 set을 이용하여 쉽게 해결이 가능하다.이 문제의 경우 주어지는 numbers의 크기를 보면, 모든 원소는 0~100사이의 수이다.따라서 이 중 두 개를 뽑아서 더해도 결과는 \\(0 \\leqq result \\leqq 200\\) 이므로,그냥 해시를 이용하여 카운팅해주어도 된다...." }, { "title": "[프로그래밍 언어] 파이썬 - 자료 구조", "url": "/posts/languagePython1/", "categories": "프로그래밍 언어, Python", "tags": "Programming, Language, Python", "date": "2020-12-07 23:00:00 +0900", "snippet": "Contents 자료 구조 줄 결합 문자열 List Tuple Dictionary Set 자료 구조줄 결합\\ 를 사용하여 명시적으로 두 개 이상의 라인을 결합할 수 있다. [], {}, () 가 사용되는 경우 \\ 없이 줄을 나눠도 된다.if x &amp;gt; 100 and y &amp;gt; 100 \\ and z &amp;gt; 100 and k &amp;gt; 100 \\ and i &amp;gt; 100: res = 100a = [1,2,3,4,..." }, { "title": "[프로그래머스 인공지능스쿨] Week2-1 인공지능 수학 : 선형대수", "url": "/posts/Day8/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-07 00:00:00 +0900", "snippet": "강의선형시스템아래와 같은 1차 방정식들을 선형시스템이라고 한다.\\[3x = 6\\]\\[x + y = 5\\]\\[2x + y = 3\\]내가 이해한게 맞다면, 그래프 상에 표현했을 때 직선으로 표현되는 수식들을 선형시스템이라고 하는 것 같다. 선형대수의 목표어떤 선형시스템의 문제라도 정형적인 방법으로 표현하고 해결하는 방법을 배우는 것이다.예를 들어,\\[3x + y + z = 4 ... E_1\\]\\[x - 2y - z = 1 ... E_2\\]\\[x + y + z = 2 ... E_3\\]이 방정식들은 각각 선형 방정식(Lin..." }, { "title": "데이터베이스 정리 5 - 트랜잭션 (Transaction)", "url": "/posts/DBCourse5/", "categories": "IT, Database", "tags": "IT, DB, Database", "date": "2020-12-06 19:20:00 +0900", "snippet": "트랜잭션 (Transaction)트랜잭션이란 데이터베이스의 상태를 변경시키는 한 개의 논리적 작업의 단위를 뜻한다.트랜잭션의 성질 원자성 (Atomicity) 한개의 트랜잭션 연산은 데이터베이스에 모두 반영되거나, 아무것도 반영되지 않아야 한다(All or nothing). 즉, 트랜잭션 내에서 한개의 연산이라도 오류가 발생한다면, 해당 트랜잭션은 모두 취소 되어야 한다. 일관성 (Consistency) 특정 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가진 경우, 트랜잭션 실행 후에도 ..." }, { "title": "[알고리즘] 프로그래머스 - 기둥과 보 설치", "url": "/posts/Algorithm33/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-05 15:00:00 +0900", "snippet": "문제기둥과 보 설치접근혼자 해결하지 못하고 해설을 보며 참고했다. 하나씩 설치 혹은 제거를 해보고 가능한 경우인지 확인하는 과정을 반복 처음에는 설치와 제거를 따로두고 확인하려고 했는데, 코드가 복잡해진다. 조건을 검사하지 않고 우선 설치 혹은 제거를 하고 난 후의 남은 결과를 이용해 조건을 검사해준다. 조건이 만족한다면 설치 혹은 제거가 성공적으로 끝난거고, 만족하지 않는다면 설치 혹은 제거를 하면 안되므로, 원래 상태로 돌려준다.조건은 현재 설치 혹인 제거된 아이템이 기둥인지 보인지에 따라 다르게 진행한다. 기둥인 경우 :..." }, { "title": "[알고리즘] 프로그래머스 - 가장 긴 팰린드롬", "url": "/posts/Algorithm32/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 23:00:00 +0900", "snippet": "문제 앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 한다. 문자열 s가 주어질 때, s의 부분문자열중 가장 긴 팰린드롬의 길이를 구하라.입출력 예시 s result “abcdcba” 7 접근혼자 해결하지 못하고 해설을 보며 참고했다. 가장 긴 문자열 부터 하나씩 길이를 줄이며 해당 문자열이 팰린드롬인지 검사를 하는 식이다. solution 함수의 바깥 포문은 부분문자열의 길이를 조정해준다.전체 문자열의 길이 부터 시작해서 1씩..." }, { "title": "[알고리즘] 프로그래머스 - 등굣길", "url": "/posts/Algorithm31/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 22:10:00 +0900", "snippet": "문제 m*n 격자의 1,1은 집, m,n은 학교이다. 일부 지역이 물에 잠겼을 때, 잠기지 않은 지역을 통해 학교에 가려한다. 최단경로의 개수를 1,000,000,007로 나눈 나머지를 반환하라.입출력 예시 m n puddles result 4 3 [[2,2]] 4 접근이건 고등학교 때 배운 것 같다. 위에서 아래로, 왼쪽에서 오른쪽으로 한칸씩 탐색하며 현재 칸까지 올 수 있는 경우의 수는 다음과 같다.d[x][y..." }, { "title": "[알고리즘] 프로그래머스 - 2 x n 타일링", "url": "/posts/Algorithm30/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 21:50:00 +0900", "snippet": "문제 가로길이가 2이고 세로길이가 1인 직사각형 모양의 타일이 있다. 이 타일을 이용하여 세로길이가 2이고 가로길이가 n인 바닥을 가득 채우는 경우의 수 구하기n은 60,000이하의 자연수 경우의 수를 1,000,000,007로 나눈 나머지를 반환입출력 예시 n result 4 5 접근DP 기본 문제이다. d[n] 의 타일링 방법은 d[n-1]의 방법들의 마지막에 세로 타일을 하나씩 추가하는 것과 d[n-2]의 방법들의 마지막에 가로타일 2개를 추가..." }, { "title": "[알고리즘] 프로그래머스 - N-Queen", "url": "/posts/Algorithm29/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 21:40:00 +0900", "snippet": "문제 n x n 체스판에 n개의 퀸이 서로를 공격할 수 없도록 배치하고 싶다. n은 12이하의 자연수입출력 예시 n result 4 2 접근한 줄씩 완전탐색을 해줄 것이다. 한 줄에 퀸이 한개만 와야하는 것은 분명하다. 문제는 대각선을 확인하는 것이다. 이 경우들을 확인하기 위해 각 상태를 저장해둔 배열 3개를 만들었다. 같은 열에 퀸이 있는지, 오른쪽방향과 왼쪽방향으로 대각선에 퀸이 있는지를 담고 있는 배열이다. 대각선의 인덱스 조절에 신경..." }, { "title": "[알고리즘] 프로그래머스 - 빙고", "url": "/posts/Algorithm28/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 21:30:00 +0900", "snippet": "문제 N x N 보드판에서 빙고를 하자. 주어지는 수를 모두 지운 후 몇 빙고인지 구하라. N 은 2이상 500이하의 자연수 board의 각 칸에는 1이상 NxN 이하의 자연수가 중복없이 들어 있다. nums는 지울 숫자가 들어있는 배열이며, 길이는 1이상 NxN 이하이다. nums에 들어 있는 숫자는 1이상 NxN이하의 자연수이며, 중복은 없다.입출력 예시 board nums result [[11,13,15,16],[12,1,4,3],[10,2,7,8],..." }, { "title": "[알고리즘] 프로그래머스 - 게임아이템", "url": "/posts/Algorithm27/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 21:00:00 +0900", "snippet": "문제 XX 게임의 유저들이 보스 몬스터를 사냥하려고 팀을 만들었습니다. 그리고 팀에 속한 캐릭터에 아이템을 사용해 공격력을 높이려 합니다. 이 게임의 아이템은 캐릭터의 공격력은 높이고 체력을 낮춥니다. 그래서 아이템을 적절히 사용해 팀의 공격력을 최대한 끌어올리려 합니다. 캐릭터별로 아이템을 사용할지 말지는 자유지만, 아이템을 사용한 캐릭터는 체력이 반드시 100 이상 남아야 합니다. 또, 한 캐릭터에 아이템 하나씩만 사용할 수 있으며, 사용한 아이템은 사라집니다. 캐릭터들의 체력을 담은 배열 healths와 아이템별..." }, { "title": "[알고리즘] 프로그래머스 - 방문 길이", "url": "/posts/Algorithm26/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 19:00:00 +0900", "snippet": "문제 LRUD 명령어를 이용해 캐릭터를 움직인다. 캐릭터는 0,0에서 시작하며 -5,5 의 범위를 가지는 2차원 좌표계 내에서 움직일 수 있다. 경계를 넘어가면 명령어는 무시한다. 처음으로 걸어본 길의 길이를 구하자 명령어 dirs는 string이며 U, D, R, L 이외의 문자는 주어지지 않음 dirs의 길이는 500이하입출력 예시 dirs result “ULURRDLLU” 7 접근해당 좌표에 방문했는지는 중..." }, { "title": "[알고리즘] 프로그래머스 - FloodFill", "url": "/posts/Algorithm25/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 18:30:00 +0900", "snippet": "문제 n x m 크기의 도화지에 그려진 그림의 색깔이 주어짐 같은 색깔은 같은 숫자로 나타남 그림에 있는 영역의 개수 구하기 n, m은 1이상 250이하인 정수 그림의 색은 1이상 30,000 미만인 정수입출력 예시 n m images result 2 3 [[1, 2, 3], [3, 2, 1]] 5 접근2차원 배열에서의 BFS문제이다. 아직 검사하지 않은 좌표에서 BFS를 이용하여 연결된 영역들을 검출..." }, { "title": "[알고리즘] 프로그래머스 - 배달", "url": "/posts/Algorithm24/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 18:00:00 +0900", "snippet": "문제 N개의 마을에 1부터 N까지 번호가 부여되어 있음 마을들은 양방향 도로가 존재 1번 마을에서 각 마을에 음식 배달 K 시간 이하로 걸리는 마을만 배달 가능 배달 할 수 있는 마을의 개수를 구하라 마을 개수 N은 1이상 50이하 road의 길이(도로 정보의 개수)는 1이상 2,000이하 road의 각 원소는 (a, b, c)로 이루어져 있음 a, b는 마을 번호, c는 도로를 지나는데 걸리는 시간 도로 정보는 중복되지 않음 K는 배달 가능 시간이며, 1이상 500,000 이하입출..." }, { "title": "[알고리즘] 프로그래머스 - 문자열 압축", "url": "/posts/Algorithm23/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 17:30:00 +0900", "snippet": "문제 문자열을 압축할 때 가장 짧게 표현할 수 있는 방법 ex) abcabcdede : 3개씩 압축하면 2abcdede 문자열 s의 길이는 1 이상 1,000 이하 s는 알파벳 소문자로만 이루어져 있음입출력 예시 s result “aabbaccc” 7 “ababcdcdababcdcd” 9 “abcabcdede” 8 “abcabcabcabcdededededede..." }, { "title": "[알고리즘] 프로그래머스 - 주사위 게임", "url": "/posts/Algorithm22/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 17:10:00 +0900", "snippet": "문제 1차원 보드칸, 주사위 3개 주사위는 각각 1부터 S1, S2, S3까지의 숫자 중 한개가 나옴 캐릭터는 좌표 1에서 시작하여 주사위 3개의 눈금 합만큼 이동 몬스터가 있는 좌표가 주어졌을 때, 주사위를 한번 굴려서 몬스터를 만나지 않을 확률구하기 monster는 몬스터의 위치를 담은 배열, 길이는 1이상 99이하 monster의 각 원소는 2이상 100이하, 중복 없음 각 주사위의 최댓값 2 &amp;lt;= S1 &amp;lt;= 30, 2 &amp;lt;= S2 &amp;lt;= 30, 2 &..." }, { "title": "[알고리즘] 프로그래머스 - 사전순 부분문자열", "url": "/posts/Algorithm21/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 16:50:00 +0900", "snippet": "문제 문자열 s로 만들 수 있는 부분 문자열 중 사전 순 가장 뒤에 나오는 문자열 찾기 s의 순서는 바꾸지 않음 문자열 s의 길이 : 1이상 1,000,000 이하 문자열은 모두 소문자로 이루어짐입출력 예시 s return “xyb” “yb” 접근이전 문자열보다 큰 문자가 나오면 이전 문자열 중 현재 문자보다 작은 문자를 모두 지워주는 식으로 구현한다. 원래 while이 아닌 if로 구현했는데 이 경우 이전 문자 한개만을 비..." }, { "title": "[알고리즘] 프로그래머스 - 짝지어 제거하기", "url": "/posts/Algorithm20/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 16:40:00 +0900", "snippet": "문제 문자열에서 같은 알파벳이 2개 붙어 있으면 제거하고, 앞뒤 문자열을 이어 붙인다. 모든 문자를 제거할 수 있으면 1, 아니면 0을 리턴 문자열 s의 길이 : 1,000,000 이하의 자연수 문자열은 모두 소문자로 이루어짐입출력 예시 s return baabaa 1 접근문자열에서 연속된 두개를 검출 -&amp;gt; 제거만 반복하면 된다. 나는 한글자씩 꺼내어 비교하는 방식으로 해결했다. 새로운 리스트를 하나 만들어 s에서 한글자씩 꺼내..." }, { "title": "[알고리즘] 프로그래머스 - 배상 비용 최소화", "url": "/posts/Algorithm19/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 16:30:00 +0900", "snippet": "문제 배상 비용은 선박 완성까지 남은 작업량을 제곱하여 모두 더한 값 남은 작업 시간 N을 이용하여 배상 비용을 최소화 작업 가능한 남은 시간 : N 각 일에 대한 작업량 : works N은 1,000,000이하의 자연수 works의 크기는 1,000 이하의 자연수 각 일에 대한 작업량 : 1,000 이하의 자연수입출력 예시 N works return 4 [4, 3, 3] 12 접근제곱의 합을 최소화하기 위해..." }, { "title": "[알고리즘] 프로그래머스 - 스킬트리", "url": "/posts/Algorithm18/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 16:20:00 +0900", "snippet": "문제 선행 스킬 순서가 주어질 때, 유저들의 스킬트리가 옳바른지 판단 선행 스킬 순서 : skill 유저들이 만든 스킬트리를 담은 배열 : skill_trees 모든 스킬은 알파벳 대문자 skill의 길이는 1이상 26이하, 중복 없음 skill_trees의 길이는 1이상 20이하 skill_tress의 원소의 길이는 2이상 26이하, 중복 없음입출력 예시 skill skill_trees return “CBD” [..." }, { "title": "[알고리즘] 프로그래머스 - 세 소수의 합", "url": "/posts/Algorithm17/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 16:10:00 +0900", "snippet": "문제 어떤 수를 서로 다른 소수 3개의 합으로 표현하는 경우의 수 n이 주어질 때 n을 서로 다른 소수 3개의 합으로 표현 n은 1,000이하의 자연수입출력 예시 n return 33 4 접근2단계로 나누어서 푼다. n 이하의 소수 구하기 구한 소수들을 더하는 경우의 수 완전탐색하기소수를 구하는 알고리즘은 에라토스테네스의 체 라는 알고리즘을 이용했다. 이 알고리즘은 간단하면서도 효과적이다. 2부터 시작하여 해당 수를 제..." }, { "title": "[알고리즘] 프로그래머스 - 대중소 괄호 짝 맞추기", "url": "/posts/Algorithm16/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 16:05:00 +0900", "snippet": "문제 괄호 짝 맞추기 문자열 s는 (,),{,},[,] 로만 이루어져 있음 짝이 맞으면 True, 틀리면 False s의 길이는 1이상 40이하입출력 예시 s return ”[[]]” true 접근스택의 기본 문제이다. 여는 괄호가 나오면 스택에 넣고, 닫는 괄호가 나오면 스택에서 하나 빼서 맞는 괄호쌍인지 검사한다. 딕셔너리를 이용한다면 맞는 괄호쌍인지 검사하는 코드가 간결해진다. 주의할 점은 스택이 비어있는데 닫는 괄호가 ..." }, { "title": "[알고리즘] 프로그래머스 - 좌석 구매", "url": "/posts/Algorithm15/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-04 16:00:00 +0900", "snippet": "문제 격자모양의 공연 좌석 K명의 관람객이 매표소에서 티켓을 구매 자신이 원하는 좌석이 아니면 구매하지 않음 표를 구하는데 성공한 사람의 수를 구하라 가로, 세로 좌석 범위는 1이상 100,000 이하 관람객 수는 1이상 100,000이하입출력 예시 seat return [[1,1],[2,1],[1,2],[3,4],[2,1],[2,1]] 4 접근전체 관람객 수에서 중복을 제거하는 문제이다. 파이썬에서는 중복을 베제할 수 있는 ..." }, { "title": "[프로그래머스 인공지능스쿨] Week1-5 파이썬 기초", "url": "/posts/Day5/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-04 15:00:00 +0900", "snippet": "강의오늘은 문제만 풀었다. 하루에 이렇게 문제를 많이 풀 수 있다는 것을 처음 알았다. 겹치지 않는 문제만 링크를 걸자. 문제문제 1 - 좌석 구매문제 2 - 대중소 괄호 짝 맞추기문제 3 - 세 소수의 합문제 4 - 스킬트리문제 5 - 배상 비용 최소화문제 6 - 짝지어 제거하기문제 7 - 사전순 부분문자열문제 8 - 주사위 게임문제 9 - 문자열 압축문제 10 - 배달문제 11 - FloodFill문제 12 - 방문 길이문제 13 - 게임아이템문제 14 - 빙고문제 15 - N-Queen문제 16 - 2 x n 타일링문제..." }, { "title": "[알고리즘] 백준 1926 - 그림", "url": "/posts/BOJ2/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 그림, BFS", "date": "2020-12-03 23:30:00 +0900", "snippet": "문제1926 - 그림접근기본적인 BFS 문제이다. 1인 영역을 검출하는 단계 검출된 영역에서 BFS를 이용하여 연결된 1을 찾는 단계로 이루어진다.코드 C++ 코드#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;int board[500][500];int dx[4] = {0, 1, 0, -1};int dy[4] = {-1, 0, 1, 0};int maxSize = 0;int n, m;queue&amp;lt;pair&amp;lt;..." }, { "title": "[알고리즘] 백준 1182 - 부분수열의 합", "url": "/posts/BOJ1/", "categories": "Algorithm, BOJ", "tags": "Algorithm, BOJ, Python, 백준, 알고리즘, 파이썬, 부분수열의 합", "date": "2020-12-03 23:00:00 +0900", "snippet": "문제1182 - 부분수열의 합접근각 원소를 더하거나 더하지 않는 모든 경우의 수를 탐색하는 방법으로 해결할 수 있다. 원소에 음수도 포함되어 있기 때문에 마지막까지 탐색해봐야 결과를 알 수 있음 마지막에 s가 0인 경우는 아무거도 더하지 않은 경우에도 성립되므로, 결과에서 1을 빼줌코드 C++ 코드#include&amp;lt;iostream&amp;gt;using namespace std;int func(int nowIdx, int sum);int arr[30];int n, s;int main() { cin &amp;..." }, { "title": "데이터베이스 정리 4 - 정규화 (Normalization)", "url": "/posts/DBCourse4/", "categories": "IT, Database", "tags": "IT, DB, Database", "date": "2020-12-03 22:30:00 +0900", "snippet": "정규화 (Normalization)데이터베이스의 설계에서 중복을 최소화할 수 있도록 데이터를 구조화하는 작업 갱신 이상 (Update Amomaly) 수정 이상 (Modification anomaly) : 중복 데이터의 일부가 수정되면 데이터 불일치 발생 삽입 이상 (Insertion anomaly) : 불필요한 정보 없이는 어떠한 정보의 저장이 불가능 삭제 이상 (Deletion anomaly) : 유용한 정보를 함께 제거하지 않으면 어떠한 정보의 삭제가 불가능 함수 종속성 (Functional Dependency)Re..." }, { "title": "데이터베이스 정리 3 - 무결성 제약조건", "url": "/posts/DBCourse3/", "categories": "IT, Database", "tags": "IT, DB, Database", "date": "2020-12-03 22:00:00 +0900", "snippet": "무결성무결성이란 데이터의 정확성, 일관성을 나타냄 데이터베이스는 무결성을 항상 만족해야함 무결성 종류 도메인 무결성 : 속성들의 값은, 정의된 도메인에 속한 값이어야 함 키 무결성 : 각 Relation은 적어도 한개 이상의 키가 존재해야 함 참조 무결성 : Relation은 참조 불가능한 외래키 값을 가질수 없음 고유 무결성 : Relation의 특정 속성에 대해 각 튜플이 가지는 값은 서로 달라야함 널 무결성 : Relation의 특정 속성 값은 Null이 될 수 없음 무결성 제약조건데이터베이스의 정확성, 일관성을..." }, { "title": "[알고리즘] 프로그래머스 - 여행경로", "url": "/posts/Algorithm14/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-03 19:30:00 +0900", "snippet": "문제 주어지는 항공권을 모두 이용하여 여행경로 짜기 출발점은 항상 “ICN” 주어지는 공항 수는 3개 이상 10,000개 이하tickets의 각 행 [a, b]는 a공항에서 b 공항으로 가는 항공권 주어지는 항공권을 모두 사용해야함. 가능한 경로가 2개 이상일 경우 알파벳 순서 모든 도시를 방문할 수 없는 경우는 주어지지 않음입출력 예시 tickets return [[“ICN”, “JFK”], [“HND”, “IAD”], [“JFK”, “HND”]] ..." }, { "title": "[알고리즘] 프로그래머스 - N으로 표현", "url": "/posts/Algorithm13/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-03 18:00:00 +0900", "snippet": "문제 숫자 N과 사칙연산만을 이용하여 number를 표현하라. 가능한 방법중 N을 가장 적게 사용하용하는 값을 반환하라. ex) 12 = (55+5)/5주어지는 숫자 : N 만들고자 하는 수 : number N은 1이상 9 이하 number는 1이상 32,000 이하 나누기 연산의 나머지는 무시 최솟값이 8보다 크면 -1 리턴입출력 예시 N number return 5 12 4 2 11 3 ..." }, { "title": "[알고리즘] 프로그래머스 - 더 맵게", "url": "/posts/Algorithm12/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-03 16:30:00 +0900", "snippet": "문제 주어지는 모든 음식의 스코빌 지수를 K이상으로 만들기 위해스코빌 지수가 가장 낮은 음식 두 개를 섞어서 새로운 음식을 만든다. 모든 음식의 스코빌 지수가 K 이상이 되도록 만들자. \\(스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)\\) 음식들의 스코빌 지수를 담은 배열 : scoville 원하는 스코빌 지수 : K scoville의 길이는 1이상 1,000,000 이하 K는 0이상 1,000,000,000 이하 scoville의 원소는 각각 0이..." }, { "title": "[프로그래머스 인공지능스쿨] Week1-4 파이썬 기초", "url": "/posts/Day4/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-03 16:00:00 +0900", "snippet": "강의Python Library Heap파이썬에서 라이브러리로 최소 힙(Min Heap) 자료구조를 제공한다.일반 리스트를 힙처럼 사용할 수 있도록 도와준다.C++ 이나 자바에서 처럼 별개의 자료구조를 제공하는게 아니다.선언은 일반 리스트와 똑같다.import heapqheap = []일반 리스트를 변환heapq.heapify(heap)힙에 원소 추가 및 삭제heapq.heappush(heap, item)item = heapq.heappop(heap)삭제하지 않고 최소값 읽기 0이외에는 순서가 보장되지 않음heap[0]자료구조..." }, { "title": "[알고리즘] 프로그래머스 - 크레인 인형뽑기 게임", "url": "/posts/Algorithm11/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-02 22:30:00 +0900", "snippet": "문제접근인형을 집는 부분, 쌓인 인형을 체크하는 부분으로 나누어서 생각했다.집는 부분은 해당 열의 데이터를 순서대로 확인하며 비어있지 않은 칸을 만나면 인형을 꺼낸다.체크하는 부분은 쌓인 인형의 가장 꼭대기와 현재 집은 인형이 같은지만 확인하면 된다.코드 파이썬 코드def solution(board, moves): answer = 0 box = [] for move in moves: for i in range(len(board)): if board[i][move-1] != 0:..." }, { "title": "데이터베이스 정리 2 - 관계형 데이터 모델", "url": "/posts/DBCourse2/", "categories": "IT, Database", "tags": "IT, DB, Database", "date": "2020-12-02 21:00:00 +0900", "snippet": "관계형 데이터 모델 (Relational data model)동일한 구조(관계)의 관점에서 모든 데이터를 논리적으로 구성 높은 데이터 독립성을 제공 기본 용어 관계 (Relation) : 2차원 테이블 Tuple : 각 행(row)을 나타냄 Attributes : 각 속성(col)을 나타냄 Cardinality : 행의 개수 Degree : 속성(col)의 개수도메인 (Domain) 각 속성(Attributes)에서 나타날 수 있는 모든 값들의 집합 도메인은 원자값(더 이상 쪼개질 수 없는 속성)을 가짐 프로그..." }, { "title": "데이터베이스 정리 1 - 스키마, DBMS", "url": "/posts/DBCourse1/", "categories": "IT, Database", "tags": "IT, DB, Database", "date": "2020-12-02 20:00:00 +0900", "snippet": "Database schema데이터베이스 스키마(schema)는 DB의 구조와 제약 조건에 대하여 전반적인 명세를 정의한 메타데이터의 집합이다. 스키마 3계층 외부 스키마 (External Schema) 개별 사용자들의 입장에서 데이터 베이스를 정의한 내용 동일한 데이터에 대해서 다른 표현을 제공 개념 스키마 (Conceptual Schema) 물리적 구현은 고려하지 않고, 데이터베이스의 전체 조직에 대한 논리적인 구조 데이터 사이에 존재하는 관계 및 무결성 제약 조건에 대한 명세 정의 각 데이터베이스에는 한개의 개념 스키..." }, { "title": "[알고리즘] 프로그래머스 - 큰 수 만들기", "url": "/posts/Algorithm10/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-02 17:30:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 수 구하기 숫자 : number 제거할 개수 : k number는 1자리 이상 1,000,000자리 이하인 숫자 k는 1이상 number의 자릿수 미만인 자연수입출력 예시 number k return “1924” 2 “94” 접근탐욕법을 이용하여 풀 수 있다. 앞자리에 큰 숫자가 나올수록 전체 수의 크기는..." }, { "title": "[알고리즘] 프로그래머스 - 체육복", "url": "/posts/Algorithm9/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-02 16:30:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. 일부 학생이 체육복을 도난 당했다. 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 한다. 빌려줄 때 바로 앞번호나 뒷번호의 학생에게만 빌려줄 수 있다. 적절히 빌려주어 최대한 많은 학생이 체육 수업을 들을 수 있도록 하자. 전체 학생 수 : n 도난당한 학생들의 번호 : lost 여벌을 가진 학생들의 번호 : reserve 전체 학생 수는 2명 이상 30명 이하이다. 도난당한 학생은 1명 이상 n명 이하이고, 중복은 없다. 여벌을 가져온..." }, { "title": "[알고리즘] 프로그래머스 - 완주하지 못한 선수", "url": "/posts/Algorithm8/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-02 15:55:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. 마라톤에 참여한 선수 중 한명을 제외하고 모두 완주했다. 이때 완주하지 못한 선수의 이름을 찾아라. 참여 선수 이름이 담긴 배열 : participant 완주 선수 이름이 담긴 배열 : completion 참여한 선수는 1명 이상 100,000명 이하이다. completion의 길이는 participant보다 1작다. 참가자의 이름은 1~20글자의 알파벳 소문자로 이루어져 있다. 동명이인이 있을 수 있다.입출력 예시 participant ..." }, { "title": "[프로그래머스 인공지능스쿨] Week1-3 파이썬 기초", "url": "/posts/Day3/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-02 14:00:00 +0900", "snippet": "강의Python Dictionary파이썬에서 제공하는 딕셔너리 자료형을 배웠다.딕셔너리는 Key, Value를 이용하여 대응 관계를 나타낼 수 있는 자료형이다.배열과 다르게 { } 를 이용한다. 딕셔너리에서 Key, Value 값 얻기dic.key()dic.values()dic.items()items를 이용하면 두 값을 모두 얻을 수 있다. 값을 리스트에 담으려면 list()로 감싸주면 된다.list(dic.key()) Key를 이용하여 Value 얻기dic.get(key)dic[key]두 방법으로 동일한 결과를 가질 수 ..." }, { "title": "[알고리즘] 프로그래머스 - 최솟값 만들기", "url": "/posts/Algorithm7/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-02 01:55:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. 길이가 같은 배열 A, B가 있다. A, B 배열에서 각각 한 개의 숫자를 뽑아 두 수를 곱하는 과정을 길이만큼 반복하며, 곱한 값을 누적하여 더한다. (중복으로 뽑을 수는 없다) 이때 최종적으로 누적된 값이 최소가 되도록 하자. A, B의 크기 : 1000이하의 자연수 A, B의 원소의 크기 : 1000이하의 자연수입출력 예시 A B return [1, 4, 2] [5..." }, { "title": "[알고리즘] 프로그래머스 - 가장 큰 수", "url": "/posts/Algorithm6/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-02 01:55:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. 0 또는 양의 정수가 주어졌을 때, 정수들을 이어 붙여 만들 수 있는 가장 큰 수 찾기 0 또는 양의 정수가 담긴 배열 : numbers 1 &amp;lt;= numbers의 길이 &amp;lt;= 100,000 각 원소는 0이상 1,000 이하입출력 예시 numbers return [6, 10, 2] “6210” [3, 30, 34, 5, 9] ..." }, { "title": "[알고리즘] 프로그래머스 - 기능개발", "url": "/posts/Algorithm5/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-02 01:45:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. 각 기능 개발을 하는데 걸리는 속도는 모두 다르다. 기능은 진도가 100% 일 때 서비스에 반영할 수 있다. 먼저 배포해야하는 순서대로 문제가 주어졌을 때 각 배포마다 몇 개의 기능이 배포되는지를 구하는 문제. 작업의 진도가 적한 배열 : progresses 각 작업의 개발 속도 배열 : speeds 1 &amp;lt;= progresses, speeds의 길이 &amp;lt;= 100입출력 예시 progresses ..." }, { "title": "[알고리즘] 프로그래머스 - 예산_소팅", "url": "/posts/Algorithm4/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python, Cpp", "date": "2020-12-02 01:30:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. 부서 별로 예산을 지원해준다. 짤라주기는 불가능 필요한 예산은 전액만 지원 가능 예를 들어 1000원이 필요한 부서에는 1000원을 지원해야함. 500원 지원 불가. 전체 예산이 정해져 있을 때, 최대한 많은 부서를 지원하자! 부서별 신청 금액 : d 전체 예산 : budget 1 &amp;lt;= d의 길이 &amp;lt;= 1001 &amp;lt;= d 원소의 크기 &amp;lt;= 100,000 1 &amp;lt;= budget &amp..." }, { "title": "[프로그래머스 인공지능스쿨] Week1-2 파이썬 기초", "url": "/posts/Day2/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-02 01:15:00 +0900", "snippet": "강의오늘은 별로 적을 내용이 없다.트리, 특히 이진 트리를 열심히 배웠다.문제문제 1 - 예산_소팅문제 2 - 기능개발문제 3 - 가장 큰 수문제 4 - 최솟값 만들기" }, { "title": "[알고리즘] 프로그래머스 - 사탕 담기", "url": "/posts/Algorithm3/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-02 01:11:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. m 그램을 담을 수 있는 가방에 사탕을 가득 채우는 경우의 수 찾기 중복 불가 가방에 담을 수 있는 무게 : m 사탕별 무게가 담긴 배열 : weights 1,000 &amp;lt;= m &amp;lt;= 100,000 10 &amp;lt;= 사탕의 무게 &amp;lt;= 100,0003 &amp;lt;= weights의 길이 &amp;lt;= 15입출력 예시 m weights return ..." }, { "title": "[알고리즘] 프로그래머스 - 카펫", "url": "/posts/Algorithm2/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-02 01:00:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. 한칸의 길이가 1인 정사각형들로 이루어진 직사각형이 있다. 테두리 칸들은 갈색, 그 외는 빨간색으로 칠해져 있다. 갈색과 빨간색 칸의 개수가 주어졌을때, 직사각형의 가로, 세로 크기를 구하자 갈색 격자 : brown 빨간색 격자 : red 8 &amp;lt;= brown &amp;lt;= 5,000 1 &amp;lt;= red &amp;lt;= 2,000,000 카펫의 가로 길이는 세로 길이보다 크거나 같다.입출력 예시 brow..." }, { "title": "[알고리즘] 프로그래머스 - 운송트럭", "url": "/posts/Algorithm1/", "categories": "Algorithm, Programmers", "tags": "Algorithm, Programmers, Python", "date": "2020-12-02 00:28:00 +0900", "snippet": "문제강의에 들어있는 문제라서 문제 링크를 걸어도 되는지 모르겠다. 한정된 트럭 용량에 순서대로 상품들을 실을 때, 몇 대의 트럭이 필요한지 구하는 문제이다. 트럭의 허용 무게 : max_weight 상품별 무게 : specs 운반할 상품이 순서대로 담긴 배열 : names 1 &amp;lt;= max_weight &amp;lt;= 100,000 1 &amp;lt;= specs의 길이 &amp;lt;= 100,000 1 &amp;lt;= names의 길이 &amp;lt;= 10,000입출력 예시 max_we..." }, { "title": "[프로그래머스 인공지능스쿨] Week1-1 파이썬 기초", "url": "/posts/Day1/", "categories": "Course, AI Dev Course", "tags": "Programmers, AI, Python", "date": "2020-12-01 22:53:00 +0900", "snippet": "강의파이썬 기초를 전반적으로 보고 있다.그 중 내가 모르거나 햇갈렸던 것만 정리할 것이다. List pop 연산list.pop(index)여기서 index가 음수이면 뒤에서 부터 찾아온다.예를 들어,l = [1,2,3,4]l.pop(-1)을 하면 4가 반환 되는 식 List sort정렬 방식은 두 가지가 있다.sorted 는 파이썬 내장함수,sort 는 list method.#sortedl1 = [5,4,3,2,1]l2 = sorted(l1)# 결과# l1 = [5,4,3,2,1]# l2 = [1,2,3,4,5]sorted..." } ]
