---
title: "[프로그래머스 인공지능스쿨] Week8-3 Deep Learning: 최적화 (2)"
author: Daekyo Jeong
date: 2021-01-28 00:00:00 +0900
categories: [강의, AI]
tags: [Programmers, AI, Python]

math: true
---

# **강의**   
<br/>

## **활성 함수(Activation function)**  

각 layer들을 거치면서 수행하는 연산들은 모두 선형적인 연산이다.  
이러한 선형적 연산에 비선형적인 연산을 추가하기 위해 각 layer의 연산결과에 비선형 활성함수를 적용한다.  

### **$$\rhd$$ Sigmoid**  

Sigmoid 활성화 함수는 0, 1 사이의 값을 가지도록 설계되어 있다.  
초기 신경망들에서 많이 사용했지만, 최근에는 Sigmoid가 가지는 단점들 때문에 학습에 거의 사용하지 않는다.  
가장 큰 문제는 역전파 과정은 결국 미분을 한 값을 전달한다.  
이 때 sigmoid 함수의 미분값은 활성값이 커지면 포화 상태가 되고, 경사도가 0에 가까워지는 문제가 있다.  
즉, 미분값이 소실되는 gradient vanishing 문제가 있다.  
이에 따라 역전파과정에서 가중치 갱신을 제대로 해주지 못한다.  


### **$$\rhd$$ tanh(Hyperbolic tangent function)**  

기존 Sigmoid 함수는 중심값이 1/2이기 때문에 최적화 느리게 진행되는 경향을 보였다.  
tanh는 기존 sigmoid 함수를 transformation 하여, 중심값을 0으로 옮겨줌으로써 이 문제를 해결하였다.  
하지만 여전히 gradient vanishing 문제가 남아있다.  

### **$$\rhd$$ ReLU(Rectified Linear Unit)**  

ReLU는 최근에 가장 많이 사용되는 활성화 함수이다.  
활성값을 1로 제한하지 않음으로써, gradient vanishing 문제를 해결하였다.  
하지만 0보다 작은 값들은 모두 0으로 맞춰줌으로써 0보다 작은 값들에 대해서는 기울기가 항상 0이다.  
이러한 점때문에 한번 활성화가 안된 뉴런들은 영원히 활성화되지 않을 수 있는 문제가 있다.  

### **$$\rhd$$ Leaky ReLU**  

ReLU에서 비활성화 문제를 해결하기 위해 등장했다.  
0보다 작은 값에 대해서 매우 미세한 값을 곱하여 미세한 기울기를 만들어주는 것으로, 비활성화된 뉴런이 아예 죽는 문제를 해결한다.  

### **$$\rhd$$ Maxout, ELU(Exponential Linear Unit)**  

두 함수 모두 ReLU의 장점들을 계승했으며, 뉴런이 죽는 문제를 해결하였다.  
Leaky ReLU, Maxout, ELU 활성화 함수 모두 0보다 작은 값에 대하여 즉, 비활성화되는 뉴런들이 죽지않고, 업데이트를 어떻게 해줄 것인가  
라는 문제에 초점을 맞추고, 각자의 방법으로 해결한 함수들이다.  

## **배치 정규화(Batch normalization)**  

공변량 변화(covariate shift) 현상  

훈련집합과 테스트집합의 분포가 다른경우  
학습이 잘되지 않는다.  

내부의 공변량 변화  

학습이 진행되면서 각 층의 가중치에 따라 출력이 바뀜  
다음 층의 입장에서 보면 입력받는 데이터의 분포가 수시로 바뀜  
층을 거칠수록 이러한 현상은 더욱 심해지며, 빠른 학습을 방해하는 요인이 됨  

이러한 문제를 해결하기 위해 등장한 것이 배치 정규화이다.  
배치 정규화는 층단위로 정규화를 진행해주어, 다음층에 입력되는 값을 정규화해준다.  
이 때 한개의 층은 선형적인 연산과 활성화 함수를 이용하는 비선형적인 연산이 존재한다.  
배치 정규화는 활성화 함수를 이용하기 전, 선형연산을 마친 후에 적용하는 것이 효과적이다.  

이러한 배치 정규화의 장점은 크게 다음과 같다.  

1. 신경망의 경사도 흐름을 개선했다.  
2. 학습률을 크게 하여 수렴 속도를 향상 시켰다.    
3. 가중치 초기화에 대한 의존성을 감소시켰다.  
4. 의도하지 않았지만 규제화와 유사한 행동을 하며, 드롭아웃의 필요성을 감소시켰다.  

## **규제화(Regularization)**  

학습하고자 하는 데이터에 비해 모델의 용량이 좋은 경우, Overfitting 문제가 생긴다.  
즉, 데이터보다 모델의 매개변수의 수가 많을 때, overfitting이 일어나게 된다.  
이는 훈련집합을 단순히 암기하게 되어, 학습 정확도는 높지만 테스트 데이터에서 성능이 현저하게 떨어지게 된다.  
이를 해결하기 위해 학습 과정에서 다양한 규제 기법을 적용하여 Overfitting을 방지한다.  


### **$$\rhd$$ 가중치 벌칙(Weight regularization)**  

기존 목적함수에 규제항을 추가적으로 더한다.  
매개변수를 작은 값으로 유지하도록 하므로, 모델의 용량을 제한하는 역할을 한다.  
큰 가중치에 벌칙을 주어 작은 가중치를 유지하도록 한다.  
주로 L2 norm, L1 norm을 사용한다.  


### **$$\rhd$$ 조기 멈춤(Early stopping)**  

검증 집합의 오류가 최저인 점에서 학습을 중지한다.  
Overfitting이 진행될수록 학습데이터에 대한 정확도는 계속 올라가지만, 검증 데이터에서는 정확도가 떨어지게 된다.  
즉, 검증 데이터에서의 오류가 갑자기 늘어나게 된다면 Overfitting을 의심해볼 수 있다.  
이러한 상황이 발생했을 때, 학습을 강제적으로 멈춰준다.  
이 때 단순히 한번 오류가 늘어났다고 멈추는 것이 아닌, Patience 인자를 설정하여, Patience 번 이상 오류가 증가하면 학습을 중지하도록 한다.  

### **$$\rhd$$ 데이터 확대(Data augmentation)**  

Overfitting이 발생하는 근본적인 원인인 데이터의 부족을 해결하는 방법이다.  
기존 데이터를 인위적으로 변형하여 새로운 데이터들을 생성해준다.  
Translation, Rotation, Reflection, Cropping 등의 방법을 이용하여 단순히 데이터의 양을 늘려준다.  
또한 Mrophing 기법을 이용하여 비선형적으로 다양한 형태로 변환할 수 있다.  
이 때 가장 중요한 것은 기존 데이터의 특징 자체가 손상되지 않는 범위 내에서만 변형해야 한다.  


### **$$\rhd$$ 드롭아웃(Drop out)**  

완전 연결층의 노드 중 일정 비율을 임의로 선택하여 제거하고, 남은 부분으로만 학습을 진행하는 방식이다.  
최근에는 드롭 아웃을 사용하지 않고, 배치 정규화만 진행해준다.  
검증 과정에서는 드롭 아웃을 적용하면 안된다.  


### **$$\rhd$$ 앙상블(Ensemble)**  

서로 다른 여러 개의 모델을 결합하여 일반화 오류를 줄이는 기법이다.  
모델들은 같은 구조를 사용하지만, 서로 다른 초기값과 하이퍼 파라미터를 설정하고 학습한다.  
학습이 완료되면, 각 모델들의 출력에서 평균을 구하거나, 투표하여 최종 결과를 결정한다.  

## **하이퍼 파라미터 최적화**  

우리가 알고있는 모델은 크게 두 종류의 파라미터들을 가지고 있다.  
첫 번째는 모델 내부의 파라미터, 즉 가중치를 의미한다.  
이러한 파라미터들은 학습에 의해서 결정된다.  

두 번째는 Hyper-parameter, 모델의 외부에서 모델의 동작을 조정하는 파라미터이다.  
하이퍼 파라미터의 경우 보통 사람에 의해서 결정된다.  
예를 들어, 은닉층의 개수, 필터 크기, 학습률 등이 있다.  

보통 하이퍼 파라미터를 최적화하는 방법은, 표준 참고 문헌이나 이전 연구들에서 제시하는 값들을 이용하여  
범위를 설정하고 여러 후보 값중에서 주어진 데이터에 최적인 값을 선택하는 방식을 이용한다.  

데이터에 따른 하이퍼 파라미터가 잘 설정되어야 학습이 잘 진행된다.  
최근은 기계학습으로 하이퍼 파라미터를 자동으로 튜닝하고자하는 연구들이 진행되고 있다.(Automated machine learning)  

보통 하이퍼 파라미터를 최적화하기 위해서 격자 탐색, 임의 탐색을 이용하며, 일반적으로 임의 탐색이 더 좋다.  
