---
title: "[프로그래머스 인공지능스쿨] Week8-3 Deep Learning: 최적화 (1)"
author: Daekyo Jeong
date: 2021-01-27 00:00:00 +0900
categories: [Course, AI Dev Course]
tags: [Programmers, AI, Python]

math: true
---

# **강의**   
<br/>

## **데이터 전처리**  

꼭 해야하는 것은 아니지만, 데이터에 따라 전처리를 적용했을 때 효과가 더 좋을 수도 있다.  

### **$$\rhd$$ Scale 문제**  

각 feature에 따라 값의 차이가 크거나, 작을 수 있다.  
예를 들어 첫 번째 특징은 최대 20정도의 차이가 나고, 두 번째 특징은 0.3 정도의 차이가 난다고 하자.  
이때 각 특징의 scale에 따라서 학습 속도가 크게 차이가 난다.  

이를 방지하기 위해 데이터의 Scale을 비슷하게 맞춰주는 전처리를 진행한다.  

두 번째로 모든 데이터가 양수인 경우에 발생하는 문제이다.  
학습과정에서 극단적인 상황 일때, 가중치전체가 증가하거나 감소하는 경우들이 발생한다.  
이는 최적의 파라미터를 찾는 과정에서 가중치가 크게 요동치게 되므로, 학습 속도를 저하시킬 수 있다.  

이러한 두 문제를 해결하기 위해 정규화(normalization)을 진행한다.  

정규화는 다양한 방법이 존재하는데, 여기서는 크게 두 가지를 소개한다.  

첫 번째는 정규 분포를 사용하는 경우이다.  

$$
x^{new}_{i} = \frac{x^{old}_{i} - \mu_{i}}{\sigma_{i}}, \mu = 평균, \sigma = 분산
$$

이 경우 데이터는 -1 ~ 1사이의 값을 지니게 된다.  

두 번째는 최대 최소 변환을 사용하는 경우이다.  

$$
x^{new}_{i} = \frac{x^{old}_{i} - min(x_{i})}{max(x_{i}) - min(x_{i})}
$$

이 경우 데이터는 0 ~ 1 사이의 값을 지니게 된다.  
두 번째 방법은 모든 데이터가 양수인 문제를 해결하지 못했기 때문에,   
-0.5를 더하여 데이터 분포를 -0.5 ~ 0.5로 맞춰주는 경우도 있다.  



### **$$\rhd$$ One-hot 코드 변환**  

데이터 중에 명목 변수(남녀 등)의 경우 거리 개념이 없다.  
따라서 One-hot 코드를 이용하여 값의 개수만큼 bit를 부여하여 벡터화해준다.  

## **가중치**  

최적화를 수행하는 과정에서 가중치를 어디서부터 시작하는지에 따라 최적화의 양상이 달라진다.  
따라서 가중치를 어떻게 초기화할지도 중요한 문제이다.  

### **$$\rhd$$ 대칭적 가중치 문제**  

모든 가중치가 같은 경우 중간 레이어의 값들이 똑같아 진다.  
이러한 경우 오류 역전파과정에서 갱신도 똑같이 이루어지게 된다.  
이러한 중복을 파괴하기 위해 가중치를 난수로 초기화해준다.  

보통 가우시안 또는 Uniform 분포에서 난수를 추출하며, 두 분포는 성능 차이가 거의 없다.  

초기화한 값이 너무 작은 경우, 활성 값이 0이 될 확률이 커지고, 경사도 또한 0일 확률이 커져서 학습이 되지 않는다.  
마찬가지로, 초기화한 값이 너무 크면, 활성값이 모두 활성화되고 경사도가 0이 되게 된다.  
이 경우 역시 학습이 진행되지 않는다.  
따라서 초기화는 적당한 분포를 가지도록 진행해야 한다.  

편향은 보통 0으로 초기화한다.  

## **탄력(가속도, 관성) : Momentum**  

학습을 진행할 때, 경사도에 잡음이 생길 가능성이 높고, 가중치가 급격하게 변화할 수 있다.  
Momentum은 경사도에 부드러움을 가하여 잡음 효과를 줄여서, 급격한 변화를 줄인다.  
또한 과거에 가중치의 변화를 기억하면서 기존 방향으로 일정 이상 추가적으로 이동한다.  
이를 통해 학습 속도를 향상시킨다.(지역적으로 최저점을 찾아 안장점에 빠지는 문제를 해소한다.)  
즉 loss값이 골짜기 형태로 이루어진 구간에서 빠져나오지 못하는 경우를 관성을 이용하여 넘어올 수 있도록 한다.  

## **적응적 학습률(Adaptive learning rates)**  

학습률(Learning rate)는 너무 큰 경우 가중치들이 급격하게 변하며 최적의 가중치를 지나칠 수있다.  
반대로 너무 작은 경우, 최적의 가중치까지 수렴이 너무 느리게 된다.  

기존의 경사도 갱신은 모든 매개변수에 같은 크기의 학습률을 사용한다.  
적응적 학습률은 매개변수마다 자신의 상황에 따라 학습률을 조절해서 사용한다.  
이전 경사도와 현자 경사도의 부호가 같은 매개변수는 값을 키우고, 다른 매개변수는 값을 줄이는 전략을 사용한다.  

## **최적화(Optimizer)**  

위에 서 경사도를 어떤식으로 수정해 나갈지에 대한 문제들을 다루었다.  
탄성이나 학습률의 조정 등을 통하여 최적의 가중치를 찾아나가는 방법을 개선하였고,  
이러한 방법들을 적용하고 개선해나간 다양한 최적화 기법들이 존재한다.  
대표적인 최적화 기법 몇가지에 대해 공부해보겠다.  

### **$$\rhd$$ Gradient descent(GD)**  

가장 기본이 되는 최적화 알고리즘이다.  

### **$$\rhd$$ Stochastic Gradient descent(SGD)**  

기존의 경사하강법은 한번 가중치를 업데이트 하기위해서, 전체 데이터를 학습해야 한다.  
때문에 학습 속도가 느리다는 단점을 가지고, 이를 해결하기 위해 등장한 것이 SGD이다.  
SGD 알고리즘의 경우 mini-batch 단위로 가중치 업데이트를 진행한다.  
따라서 기존 경사 하강법보다 훨씬 빠른 속도로 학습이 진행되지만,  
작은 단위로 업데이트를 진행하기 때문에, 매 업데이트마다 값이 급변할 수 있다.  

### **$$\rhd$$ Momentum**  

SGD에 위에서 설명한 관성을 적용한 최적화 알고리즘이다.  
경사도가 없어지는 경우나, 지역적 최저점 등의 문제를 탈출할 수 있어진다.  

### **$$\rhd$$ Adagrad**  

위에서 설명한 적응적 학습법을 적용한 최적화 알고리즘이다.  
차원 별로 학습 정도에 따라 학습률을 다르게 적용하며, 학습 단계에 의해서도 다르게 적용해준다.  
이 최적화 알고리즘의 경우, 오래된 경사도와 최근 경사도가 같은 비중의 역할을 한다.  

$$
r = r + g * g
$$

r은 이전의 경사도이며, g는 현재 경사도이다.  
따라서 학습을 많이 수행할 수록 r값은 점점 커지게 되며, 수렴을 방해할 수 있고, 최악의 경우 아예 학습이 안될 수도 있다.  

### **$$\rhd$$ RMSProp**  

위의 Adagrad를 조금 변형하여 문제를 개선하였다.  
$$\alpha$$라는 변수를 이용하여 이전의 경사도와 현재 경사도를 얼마나 볼지 비중을 결정한다.  

$$
r = \alpha r + (1-\alpha)g * g
$$

보통 $$\alpha$$는 0.9, 0.99, 0.999를 사용한다.  
이를 통해 과거의 r값과 현재의 값을 적당한 비율로 모두 볼 수 있도록 조정하였다.  

### **$$\rhd$$ Adam**  

위의 RMSProp에 관성을 적용한 최적화 알고리즘이다.  
학습률인 p, 모멘텀 계수값 $$\alpha_{1}$$, 가중 이동 평균 계수 $$\alpha_{2}$$를 이용하여 세밀하게 조정한다.  
일반적으로 p = 1e-3 혹은 5e-4, $$\alpha_{1} = 0.9$$, $$\alpha_{2} = 0.999$$로 설정한다.  
보통 학습과정에서 Adam, SGD를 많이 사용한다.  
하지만 SGD의 경우 직접 학습률을 변경해가면서 학습해야 좋은 결과를 보일 수 있다.  
